{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Quantified Programming! Quantified (mixed) integer programming is an extension of (mixed) integer linear programming where the variables are ordered explicitly and some variables are existentially and others are universally quantified. They can be interpreted as multistage optimization problems under uncertainty or as two-person zero-sum games between an existential and a universal (or adversarial) player. Solutions are so called winning strategies for the existential player that specify how to react on moves \u2013 certain fixations of universally quantified variables \u2013 of the universal player to certainly win the game. Our open source solver Yasol combines linear programming techniques with solution techniques from game-tree search and is able to solve multistage robust discrete optimization problems with mixed-integer recourse actions in the final decision stage. On this website we provide: the complete source code as well as precompiled executables of our solver. information regarding quantified programming and our solver . several instances in the QLP file format .","title":"Home"},{"location":"#welcome-to-quantified-programming","text":"Quantified (mixed) integer programming is an extension of (mixed) integer linear programming where the variables are ordered explicitly and some variables are existentially and others are universally quantified. They can be interpreted as multistage optimization problems under uncertainty or as two-person zero-sum games between an existential and a universal (or adversarial) player. Solutions are so called winning strategies for the existential player that specify how to react on moves \u2013 certain fixations of universally quantified variables \u2013 of the universal player to certainly win the game. Our open source solver Yasol combines linear programming techniques with solution techniques from game-tree search and is able to solve multistage robust discrete optimization problems with mixed-integer recourse actions in the final decision stage. On this website we provide: the complete source code as well as precompiled executables of our solver. information regarding quantified programming and our solver . several instances in the QLP file format .","title":"Welcome to Quantified Programming!"},{"location":"About_Yasol/","text":"About Yasol Yasol is a search based solver for so called 'Quantified integer linear programs with minimax objective\u2018 (QIP). As we additionally allow continuous decision variables in the final stage, the solver is able to deal with very specific Quantified mixed-integer linear programs (Q-MIP). The aim is to support optimization under uncertainty in a new way, based upon rigorous formal models of quantification and linear constraints. Our mission is research. The reason why we open the sources of this solver is in order to intensify the discussion whether multi-stage optimization is possible and maybe even practical. While the solver is new in the sense that there are no other QIP solver at this time (October 2022), most basic ingredients of Yasol are not new at all. The heart of the search algorithm is an arithmetic linear constraint database together with the Alphabeta algorithm which has been successfully used in gaming programs like in chess programs since many years. In order to realize fast back jumps as typically performed in SAT- and QBF- solvers, we have extended the Alphabeta algorithm as roughly described in 1 . Yasol deals with constraint learning on the so called primal side as known from SAT- and QBF-solving, as well as with constraint learning on the so called dual side, as is known from Mathematical Programming. Yasol solves multistage quantified programs with the following properties: all constraints are linear quantifiers are either existential or universal the objective is minmax (more exactly: min max min \u2026 max min max) and is linear for any single game integer variables are allowed on all exist-stages and must be greater or equal to zero only integer variables are allowed on universal stages continuous variables are allowed only on the last stage, assuming it is an existential stage all variables must be bounded from below and above, and the range between upper and lower bounds of integer variables must not exceed 40 bits In a recent computational study we showed that solving robust discrete problems with multiple stages is well within the reach of our solver 2 . It makes intensive use of a linear program solver like clp or the lp-solver of cplex. For some historical notes on Quantified Programming, Linear Programming and personal credits, we refer to our history page . For details of how to use the solver and about details of input formats etc. we refer to our download and instances page . 1 Thorsten Ederer, Michael Hartisch, Ulf Lorenz, Thomas Opfer, Jan Wolf. Yasol: An Open Source Solver for Quantified Mixed Integer Programs. ACG 2017: 224-233 2 Marc Goerigk, Michael Hartisch. Multistage Robust Discrete Optimization via Quantified Integer Programming. Computers & Operations Research, 135:105434, 2021 3 Michael Hartisch, Ulf Lorenz. A general model-and-run solver for multistage robust discrete linear optimization. Submitted to INFORMS Journal on Computing, 2023 Getting started Setting Up: After you have downloaded and compiled the current Yasol version for your operating system you are ready to go. A few things have to be kept in mind when starting Yasol: Ensure that the Yasol.ini file is present in the directory you want to call the solver from. This file is needed to load the solver setting. If it is not found the solver starts with very basic setting resulting in very long runtime. Ensure that a Folder logs is present in the directory you want to call the solver from. When running Yasol a file containing additional output information is maintained in this folder and error messages occur if this folder cannot be found. Note that these requirements are fulfilled when starting Yasol from \"Your_Yasol_Directory/bin\", where the executable is located after compiling. Calling the Solver: In order to solve an instance first be sure it adheres to the QLP file format . The solver is invoked using the following call: ./Yasol_CPLEX <Instance> [<InformationLevel>] [<TimeLimit>] The parameters in brackets are optional. With an increasing information level more output is generated mainly used for debugging purposes. If a time limit is specified the solution process is canceled after the given number seconds. Additionally, we overloaded the information level parameter: Information level \"-60\": The DEP of the binarized instance is built and solved via the linked MIP solver. Information level \"-61\": The DEP of the instance is built and solved via the linked MIP solver. Information level \"Reduce\": For instances with universal constraint system this call will return a standard QIP without universal constraints. Note that these option are not excessively tested yet. Interpreting a Solution: The main output the solver provides is the optimal objective value and the first stage solution. The principal variation, i.e. the variable assignment representing optimal play and thus the optimal objective value, can be retrieved from the logs/solutions.log file. Note that in this case \"maintainPv\" has to be set to one in the Yasol.ini file. Further, one can explicitly request a solution file solely for this instance. This can be done be setting \"writeOutputFile=1\" in the Yasol.ini file. Then, an XML formatted solution file will be created after the optimal solution was found. The name of the solution file will be the original instance file name with an attached .sol. The QLP File Format As an input for our optimization software, a new standardized file format is required. We extended the CPLEX-LP file format to handle quantifiers and to specify an order of the variables in the so called QLP file format. The following keywords are used, where new keywords are marked with .: MAXIMIZE / MINIMIZE, SUBJECT TO, BOUNDS, GENERALS, BINARIES, UNCERTAINTY SUBJECT TO , ALL , EXISTS , ORDER*, END Every keyword has to be written in capital letters. Abbreviations are not allowed. The BOUNDS section which follows the constraint section is mandatory. Each bound definition has to begin on a new line. The general form is l\u2264x\u2264u. The BOUNDS section is followed by typifying the variables. To specify any of the variables as general integer variables, a GENERAL section has to be added; to specify any of the variables as binary integer variables, a BINARY section has to be added. In every section the variables are separated by at least one space. Every variable is marked with one of the new keywords ALL or EXISTS. Analogously the variables in the ALL and EXISTS section are separated by at least one space. The order of the variables is specified below the keyword ORDER. If the instance contains a universal constraint system specifying the uncertainty set, the keyword UNCERTAINTY SUBJECT TO is used similar to SUBJECT TO for the existential constraint system. Exemplarily we will consider the following QIP instance: \\[ \\exists x_1 \\in \\left\\{0,1\\right\\} \\quad \\forall x_2 \\in \\left\\{0,1\\right\\} \\quad \\exists x_3 \\in \\left\\{0,1,2\\right\\}: \\] \\[\\begin{align} \\min \\quad -&x_1 - 2x_2 -2x_3 \\\\[5pt] \\mathrm{s.t.} \\quad &x_1 - x_2 - x_3 \\leq -1 \\\\[5pt] -&x_1 + x_2 + x_3 \\leq 1 \\\\[5pt] &x_1 + 2x_2 \\leq 3 \\end{align}\\] A typical QLP file (belonging to the above example) looks as follows (example) : MINIMIZE - x1 - 2 x2 - 2 x3 SUBJECT TO - x2 - x3 <= -1 - x1 + x2 + x3 <= 1 2 x1 + 2 x2 <= 3 BOUNDS 0 <= x1 <= 1 0 <= x2 <= 1 0 <= x3 <= 2 BINARIES x1 x2 GENERALS x3 EXISTS x1 x3 ALL x2 ORDER x1 x2 x3 END Requirements and Restrictions: Only linear constraints and objective function. integer variables are allowed in all variable blocks Continuous variables, i.e. variables not listed below the keywords BINARIES or GENERAL, have to be part of the final (existential) variable block. The right-hand side of each constraint may only contain a single parameter, i.e. all variables have to be on the left-hand side. Further Rules: Make sure that all variables are on the left-hand side of the constraint. Variables on the right-hand side are not permitted. Similarly, parameters are ignored if they appear on the left-hand side of the constraint. The letter E or e, alone or followed by other valid symbols, in particular digits, should be avoided as this notation is reserved for exponential entries. All Variables need to be bounded. You can use '-inf' and '+inf' to indicated vast bounds but note that they are still bounded by some large number. Hence, be careful when interpreting the solution. Constraints do not need to have a name. If you decide on naming them note that constraints having a constraint names starting with \"U_\" are considered universal constraints, even if they appear underneath the SUBJECT TO keyword. This option is conserved in order to be able to deal with older instances that used a different file format.","title":"About Yasol"},{"location":"About_Yasol/#about-yasol","text":"Yasol is a search based solver for so called 'Quantified integer linear programs with minimax objective\u2018 (QIP). As we additionally allow continuous decision variables in the final stage, the solver is able to deal with very specific Quantified mixed-integer linear programs (Q-MIP). The aim is to support optimization under uncertainty in a new way, based upon rigorous formal models of quantification and linear constraints. Our mission is research. The reason why we open the sources of this solver is in order to intensify the discussion whether multi-stage optimization is possible and maybe even practical. While the solver is new in the sense that there are no other QIP solver at this time (October 2022), most basic ingredients of Yasol are not new at all. The heart of the search algorithm is an arithmetic linear constraint database together with the Alphabeta algorithm which has been successfully used in gaming programs like in chess programs since many years. In order to realize fast back jumps as typically performed in SAT- and QBF- solvers, we have extended the Alphabeta algorithm as roughly described in 1 . Yasol deals with constraint learning on the so called primal side as known from SAT- and QBF-solving, as well as with constraint learning on the so called dual side, as is known from Mathematical Programming. Yasol solves multistage quantified programs with the following properties: all constraints are linear quantifiers are either existential or universal the objective is minmax (more exactly: min max min \u2026 max min max) and is linear for any single game integer variables are allowed on all exist-stages and must be greater or equal to zero only integer variables are allowed on universal stages continuous variables are allowed only on the last stage, assuming it is an existential stage all variables must be bounded from below and above, and the range between upper and lower bounds of integer variables must not exceed 40 bits In a recent computational study we showed that solving robust discrete problems with multiple stages is well within the reach of our solver 2 . It makes intensive use of a linear program solver like clp or the lp-solver of cplex. For some historical notes on Quantified Programming, Linear Programming and personal credits, we refer to our history page . For details of how to use the solver and about details of input formats etc. we refer to our download and instances page . 1 Thorsten Ederer, Michael Hartisch, Ulf Lorenz, Thomas Opfer, Jan Wolf. Yasol: An Open Source Solver for Quantified Mixed Integer Programs. ACG 2017: 224-233 2 Marc Goerigk, Michael Hartisch. Multistage Robust Discrete Optimization via Quantified Integer Programming. Computers & Operations Research, 135:105434, 2021 3 Michael Hartisch, Ulf Lorenz. A general model-and-run solver for multistage robust discrete linear optimization. Submitted to INFORMS Journal on Computing, 2023","title":"About Yasol"},{"location":"About_Yasol/#getting-started","text":"Setting Up: After you have downloaded and compiled the current Yasol version for your operating system you are ready to go. A few things have to be kept in mind when starting Yasol: Ensure that the Yasol.ini file is present in the directory you want to call the solver from. This file is needed to load the solver setting. If it is not found the solver starts with very basic setting resulting in very long runtime. Ensure that a Folder logs is present in the directory you want to call the solver from. When running Yasol a file containing additional output information is maintained in this folder and error messages occur if this folder cannot be found. Note that these requirements are fulfilled when starting Yasol from \"Your_Yasol_Directory/bin\", where the executable is located after compiling. Calling the Solver: In order to solve an instance first be sure it adheres to the QLP file format . The solver is invoked using the following call: ./Yasol_CPLEX <Instance> [<InformationLevel>] [<TimeLimit>] The parameters in brackets are optional. With an increasing information level more output is generated mainly used for debugging purposes. If a time limit is specified the solution process is canceled after the given number seconds. Additionally, we overloaded the information level parameter: Information level \"-60\": The DEP of the binarized instance is built and solved via the linked MIP solver. Information level \"-61\": The DEP of the instance is built and solved via the linked MIP solver. Information level \"Reduce\": For instances with universal constraint system this call will return a standard QIP without universal constraints. Note that these option are not excessively tested yet. Interpreting a Solution: The main output the solver provides is the optimal objective value and the first stage solution. The principal variation, i.e. the variable assignment representing optimal play and thus the optimal objective value, can be retrieved from the logs/solutions.log file. Note that in this case \"maintainPv\" has to be set to one in the Yasol.ini file. Further, one can explicitly request a solution file solely for this instance. This can be done be setting \"writeOutputFile=1\" in the Yasol.ini file. Then, an XML formatted solution file will be created after the optimal solution was found. The name of the solution file will be the original instance file name with an attached .sol.","title":"Getting started"},{"location":"About_Yasol/#the-qlp-file-format","text":"As an input for our optimization software, a new standardized file format is required. We extended the CPLEX-LP file format to handle quantifiers and to specify an order of the variables in the so called QLP file format. The following keywords are used, where new keywords are marked with .: MAXIMIZE / MINIMIZE, SUBJECT TO, BOUNDS, GENERALS, BINARIES, UNCERTAINTY SUBJECT TO , ALL , EXISTS , ORDER*, END Every keyword has to be written in capital letters. Abbreviations are not allowed. The BOUNDS section which follows the constraint section is mandatory. Each bound definition has to begin on a new line. The general form is l\u2264x\u2264u. The BOUNDS section is followed by typifying the variables. To specify any of the variables as general integer variables, a GENERAL section has to be added; to specify any of the variables as binary integer variables, a BINARY section has to be added. In every section the variables are separated by at least one space. Every variable is marked with one of the new keywords ALL or EXISTS. Analogously the variables in the ALL and EXISTS section are separated by at least one space. The order of the variables is specified below the keyword ORDER. If the instance contains a universal constraint system specifying the uncertainty set, the keyword UNCERTAINTY SUBJECT TO is used similar to SUBJECT TO for the existential constraint system. Exemplarily we will consider the following QIP instance: \\[ \\exists x_1 \\in \\left\\{0,1\\right\\} \\quad \\forall x_2 \\in \\left\\{0,1\\right\\} \\quad \\exists x_3 \\in \\left\\{0,1,2\\right\\}: \\] \\[\\begin{align} \\min \\quad -&x_1 - 2x_2 -2x_3 \\\\[5pt] \\mathrm{s.t.} \\quad &x_1 - x_2 - x_3 \\leq -1 \\\\[5pt] -&x_1 + x_2 + x_3 \\leq 1 \\\\[5pt] &x_1 + 2x_2 \\leq 3 \\end{align}\\] A typical QLP file (belonging to the above example) looks as follows (example) : MINIMIZE - x1 - 2 x2 - 2 x3 SUBJECT TO - x2 - x3 <= -1 - x1 + x2 + x3 <= 1 2 x1 + 2 x2 <= 3 BOUNDS 0 <= x1 <= 1 0 <= x2 <= 1 0 <= x3 <= 2 BINARIES x1 x2 GENERALS x3 EXISTS x1 x3 ALL x2 ORDER x1 x2 x3 END Requirements and Restrictions: Only linear constraints and objective function. integer variables are allowed in all variable blocks Continuous variables, i.e. variables not listed below the keywords BINARIES or GENERAL, have to be part of the final (existential) variable block. The right-hand side of each constraint may only contain a single parameter, i.e. all variables have to be on the left-hand side. Further Rules: Make sure that all variables are on the left-hand side of the constraint. Variables on the right-hand side are not permitted. Similarly, parameters are ignored if they appear on the left-hand side of the constraint. The letter E or e, alone or followed by other valid symbols, in particular digits, should be avoided as this notation is reserved for exponential entries. All Variables need to be bounded. You can use '-inf' and '+inf' to indicated vast bounds but note that they are still bounded by some large number. Hence, be careful when interpreting the solution. Constraints do not need to have a name. If you decide on naming them note that constraints having a constraint names starting with \"U_\" are considered universal constraints, even if they appear underneath the SUBJECT TO keyword. This option is conserved in order to be able to deal with older instances that used a different file format.","title":"The QLP File Format"},{"location":"Credits/","text":"Credits Yasol software (Ulf Lorenz, Jan. 2017) Yasol is a search based solver for so called 'Quantified mixed integer linear programs with minimax objective\u2018 (Q-MIP). The aim is to support optimization under uncertainty in a new way, based upon rigorous formal models of quantification and linear constraints. While the solver is new in the sense that there are no other Q-MIP solver at this time - Jan. 2017, most basic ingredients of Yasol are not new at all. The heart of the search algorithm is an arithmetic linear constraint database together with the Alphabeta-algorithm which has been successfully used in gaming programs like in chess programs since many years. In order to realize fast back-jumps as typically performed in SAT- and QBF- solvers, we have extended the Alphabeta-algorithm as roughly described in 7 . Yasol deals with constraint learning on the so called primal side as known from SAT- and QBF- solving, as well as with constraint learning on the so called dual side, as is known from Mathematical Programming. The most inspiring sources from our point of view are: 1 T. Achterberg: Constraint Integer Programming. Doctoral Thesis 2 T. Achterberg, T. Koch, A. Martin: Branching on History Information. ZIB-Report 02-32, Berlin, 2002 3 H. Crowder, E.L. Johnson, M. Padberg: Solving Large-Scale Zero-One Linear Programming Problems. Operations Research, 31:5, pp. 803-834, 1983 4 G. Gamrath, T. Koch, A. Martin, M. Miltenberger, D. Weninger: Progress in Presolving for Mixed Integer Programming. ZIB-Report 13-48, Berlin, 2013 5 N. S\u00f6rensson, N. Een: MiniSat v1.13 \u2013 A SAT Solver with Conflict-Clause Minimization. minisat.se/downloads/MiniSat_v1.13_short.pdf 6 F. Lonsing, A. Biere. DepQBF: A Dependency-Aware QBF Solver. JSAT 7(2-3), 71\u201376 (2010) 7 Thorsten Ederer, Michael Hartisch, Ulf Lorenz, Thomas Opfer, Jan Wolf. Yasol: An Open Source Solver for Quantified Mixed Integer Programs. ACG 2017: 224-233 8 J. Wolf: Quantified Linear Programming. Doctoral Thesis. 9 L. Zhang: Searching for truth: Techniques for Satisfiability of Boolean Formulas. Doctoral Thesis Special thanks go to Alexander Martin for many fruitful discussions and bringing the field of integer programming to my interest. History: Q-MIP and others (Jan Wolf, Jan. 2017) QLP / QIP: In 53 a QLP formulation was used to model problems from the domain of real-time scheduling 25 , with the goal to reduce the inflexibility of static scheduling in hard real-time systems. One of the fundamental features of real-time systems is the uncertain nature of execution times of tasks and the presence of complex timing constraints among them. In traditional models variable execution times are modeled through fixed worst-case values and relationships are limited to those that can be represented by precedence graphs 58 . Using QLPs as modeling tool allows to schedule tasks with varying execution times, represented by universally quantified variables, and complex timing constraints among tasks described by linear constraints. In this context, a first polynomial time algorithm to solve QLPs based on quantifier elimination techniques was proposed in 35 for a restricted class of constraints 53 , which are a subset of totally unimodular constraint systems 54 . For arbitrary linear constraints the worst-case time complexity of the proposed algorithm is double exponential 39,54 . Subramani proposed a framework to formalize scheduling problems in real-time systems using QLPs in 59 . There he focussed on the variability in the execution times, complex relationships between tasks using arbitrary linear constraints and different scheduling schemes \u2013 static (98-QLPs), co-static (89-QLPs) or parametric (alternating quantifier changes) \u2013 depending on the information available when dispatching. A detailed introduction to QLPs and methodologies to solve them are available in 32,42,60 . QIPs were studied in 61 , where a number of special cases where analyzed from the perspective of computational complexity. In that paper the authors discussed conditions under which QIPs can be relaxed to QLPs without altering the solution space. Research in this context was also supported by the Deutsche Forschungsgemeinschaft (DFG). The DFG founded project \u201cErweiterung mathemtische Optimierungsmethoden zur L\u00f6sung PSPACE-vollst\u00e4ndiger Probleme mit Hilfe quantifizierter linearer Programme\u201d at TU Darmstadt dealt with the development of algorithms to solve QIPs based on extended LP- and QLP-techniques. The DFG founded Collaborative Research Centre (SFB) 805 \u201cSonderforschungsbereich 805 - Beherrschung von Unsicherheit in lasttragenden Systemen des Maschinenbaus\u201d at TU Darmstadt deals with the control of uncertainty in mechanical systems. In this context Q-MIPs have been used to model and optimize process chains under uncertainty. Also in the context of game modeling QIPs can be applied. In 33 the PSPACE-complete two-person game Gomoku was modeled with the help of an QIP formulation, in 42 the model was adopted to the PSPACE-complete two-person game Connect-6 resulting in a 0/1-QIP that was solved with an extended variant of the algorithm proposed in 32 . Recently, extensions of traditional QLPs were presented in 34 , where the standard quantification was extended to implications of quantified linear systems, called quantified linear implications (QLI). QLPs and QLIs that arise when universally quantified variables are unbounded were studied in 50 . Whereas in the above citations the focus was on analyzing various special cases of the general problem, with a view on subclasses that are tractable, our focus lies on general QLPs with two or multiple stages without any restrictions to the quantification sequence or the constraint system. Furthermore, our focus lies on QLP optimization problems, whereas the above citations consider quantified decision problems in general. Optimization Under Uncertainty: Optimization Under Uncertainty has experienced rapid development in both theory and practice from the very beginning in the 1950s, starting with the seminal works of Beale 3 , Dantzig 29 , Bellman 4 as well as Charnes and Cooper 26 . The particular importance of optimization under uncertainty was also demonstrated in the seminal paper by Ben-Tal and Nemirovski 11 , where they showed in a detailed computational study that even a small perturbation of the problem data can make the nominal optimal solution completely meaningless from a practical viewpoint. We quote from their case study: \u201cIn real-world applications of linear programming, one cannot ignore the possibility that a small uncertainty in the data can make the usual optimal solution completely meaningless from a practical viewpoint.\u201d Due to limited computational capabilities in the past, decision models often replaced those uncertainties with averages or best estimates but recent computational advantages greatly expanded the range of optimization techniques under uncertainty. Today stochastic programming and robust optimization \u2013 two fundamentally different approaches that address optimization with data uncertainty \u2013 are the most prominent modeling paradigms and presently the subject of intense research in this field. The main difference lies in the type of uncertainty that is handled by the two methodologies. Stochastic programming assumes the uncertainty to follow a probability distribution, while robust optimization in contrast is concerned with models that contain deterministic set-based uncertainties 14 . In the following we give a brief introduction to stochastic programming and robust optimization and compare them with quantified linear programming. Stochastic Programming: The approach for uncertainty quantification used in stochastic programming (see, e.g. 22,40,48,51 and the references therein) is the representation of random parameters in the input data (c, A, b) by random variables. This approach has a long and active history dating at least as far back as Dantzigs original paper 29 and draws upon a variety of traditional operations research techniques. During the last four decades a vast quantity of literature on the subject has appeared (see, e.g. 63,64 for a stochastic programming bibliography maintained by Maarten van der Vlerk). A variety of stochastic programming applications can be found in 65 . The underlying optimization problem can be a linear program, a (mixed) integer program, but also a nonlinear program. Usually, stochastic programming models are furthermore subdivided in recourse models and chance constraint models. Recourse Models The more important and widely studied case, where most of the applications reported in the literature belong to and which has strong similarities to QLPs, is that of a stochastic linear program with recourse, which first appeared in Beale 3 and Dantzig 29 . These problems arise when some of the decision variables must be taken before the outcomes of some (or all) random events are known, and some after they become known. Recourse variables represent decisions that can be made on a \u201cwait and see\u201d basis, after the uncertainty is resolved, and they allow to adapt a solution to the specific outcome observed. Stochastic programming problems with recourse can be essentially divided into two-stage and multi-stage problems (TSSLPs and MSSLPs). In the former, a set of initial decisions are taken first, followed by a random event. After this, recourse decisions, which are based on this event, are taken. The multi-stage problem, accordingly consists of multiple stages, with a random event occurring between each stage. Chance Constraints Models: The essence of recourse models is that infeasibilities in the second or higher stages are allowed and can be compensated at a certain penalty. In chance constraint models, developed by Charnes and Cooper 26 , the focus lies on the reliability of the system in contrast. This reliability is expressed as a minimum requirement on the probability of satisfying constraints. The resulting program is called a chance-constrained stochastic program. Under certain assumptions on the probability distribution (like e.g. Normal, Cauchy, Uniform), chance- constraints can be converted into a deterministic equivalent form and then be treated as in a traditional recourse problem as mentioned above. More details on chance-constrained stochastic programming can be found in 48 . Over the last 20 years, also stochastic programming with integer or binary recourse variables has received tremendous research attention in both application and algorithmic aspects. However, compared to the continuous case of a TSSLP or MSSLP, relatively little is known on theory and algorithms for linear mixed-integer stochastic programming in general. Given that duality results do not hold in general IP and MIP formulations, it is also difficult to extend current algorithms for the linear case in order to generate cutting planes, except when only the first stage contains integer variables or other special cases. A survey of developments can be found in 55,56 , a stochastic integer programming bibliography with publications from the years 1996-2007 can be found at 63 . Compared to stochastic programming models, a QLP can be interpreted as a worst-case MSSLP with fixed recourse and only the right-hand side being affected by uncertainties. The main advantage of quantified linear and integer programming is that uncertainty can be easily modeled without detailed knowledge of the underling probability distribution. Furthermore, while SP models minimize the expected value of an objective function with respect to a set of scenarios, QLPs minimize an objective function with respect to the possible worst case (maximum loss). There is a recursive node-based definition for QLPs, similar as for MSSLPs, and it has been shown how a DEP of a QLP can be constructed. Robust Optimization: In contrast to stochastic programming, robust optimization is a more recent approach in the context of optimization under uncertainty, in which the uncertainty model is not stochastic, but rather deterministic and set-based. Instead of seeking to immunize the solution in some probabilistic sense to stochastic uncertainty, here the decision-maker constructs a solution that is valid for any realization of uncertainty in a given set 14 . While applications of stochastic programming have been reported over many years in the literature, robust optimization appeared recently, with most research in the past ten years (see, e.g. 6,12,14,16,20,62 and the references therein). The roots can be found in the field of robust control and in the work of Soyster 57 . However, high interest in both theoretical aspects and practical applications started in the first place with the work of Ben-Tal and Nemirovski 8,9 , and El-Ghaoui et al 36,37 in the late 1990s. The idea of robust optimization is to define a so-called uncertanty set U for the uncertain parameters in the input data (c, A, b) and then to require that the constraint system should hold for any possible realization of the data from U. The optimization problem modeling this requirement is called the robust counterpart problem (RCP), an optimal solution of the RCP is called robust optimal solution. The robust optimization methodology can be applied to any optimization problem (e.g. quadratically constrained quadratic programs (QCQPs) or semidefinite programs (SDPs)), in which the uncertain data is known to lie in a given uncertainty set. Though it is still a relatively new approach, it has already proved very useful in many applications. In 6 a list of problem classes for which robust optimization is applicable is listed. One might imagine that the addition of robustness to a general optimization problem comes at the expense of a significantly increased computational complexity, and indeed, the RCP of an arbitrary convex optimization problem is in general intractable 6 . Nevertheless, depending on the structure of the underlying optimization problem and the uncertainty set U , the corresponding RCP can be solved or at least be approximated in polynomial time for many application cases 9 . Ben-Tal and Nemirovski 10 showed that the RCP of a linear optimization problem is essentially always tractable for many practical uncertainty sets. Due to the results in 6 , in the case of robust linear optimization, the objective and the right-hand side of the constraints can be assumed to be deterministic and w.l.o.g. constraint-wise uncertainty can be assumed. It hence suffices to focus on single constraints of a special form. These are referred as the subproblems which must be solved in order to solve the entire RCP. Of course, a major modeling decision concerns the choice of the uncertainty set U and the resulting RCP might not longer be an LP 5 . In particular, the RCP of an LP with a polyhedral uncertainty set becomes a linear programming problem, while the RCP of an LP with an ellipsoidal uncertainty set becomes a second-order cone problem respectively 12 . Other interesting results have been achieved recently, e.g. under very natural assumptions, robust LPs can be formulated as semi-definite programming problems and thus solved by a polynomial time approximation scheme 6,9 . Several attempts to extend the ideas to discrete robust optimization have been e.g. made in 15,17,18 . However, unlike the case of continuous robust optimization, the conditions on the uncertainty sets are rather restrictive to still ensure the efficient solvability of the RCP as shown in 17 . Therefore, approximation techniques based on piecewise linearization are currently the means of choice for such problems 20 . While stochastic programming problems can result in large deterministic linear models when considering many scenarios, the RCP models grow only slightly when uncertainty is added in general and therefore, they can often be solved efficiently. Another crucial difference is that in the stochastic programming approach constraints may be violated with a certain probability (chance-constraints) or at a given penalty (recourse model), whereas robust optimization is associated with hard constraints, which must be satisfied whatever the realization of the data (c, A, b) in the uncertainty set U is 10 . Thus, in many cases a single-stage robust optimization model tends to be to conservative 2 , especially in situations where some recourse decisions can be made after the uncertainty is revealed. To address this issue, two-stage models \u2013 also called robust adjustable or adaptable optimization \u2013 were proposed e.g. in 7 . However, two-stage problems are very challenging to compute, even formulations with LP problems in both stages can be NP-hard 7 . Nevertheless, in many real-world problems, decisions and uncertainty are often repeatedly interwoven over time and RO model are not capable to handle this efficiently due to the difficulty in incorporating multiple stages 62 . From the viewpoint of quantified linear and integer programming, robust optimization problems can be viewed as QLPs with one quantifier change (98), whereas in QLPs multiple quantifier changes occur in general. However, from the viewpoint of robust optimization, where arbitrary uncertainty sets may appear (though not necessarily being tractable at all), the uncertainty set of QLPs is a simple hyperrectangle. Other LP-based solution techniques: Apart from stochastic programming and robust optimization as mentioned above, typical solution approaches for problems that are affected by uncertainty are sensitivity analysis 49 , LP-based approximation techniques 45 , dynamic programming 4 , and the exploration of Markov-chains 69 for example. Sensitivity analysis is a simple classical method of addressing uncertainty, which is typically applied as a post-optimization tool for quantifying the goodness or robustness of a solution, e.g. the change in cost for small perturbations in the underlying problem data. It is not particularly helpful for generating solutions that are robust to data changes in the sense of an a priori ensured feasibility when the problem parameters vary within the prescribed uncertainty set 67 . A further possibility to deal with these uncertainties is an approximation where a given probability distribution is aggregated to a single estimated number. Then, the optimum concerning these estimated input data can be computed with the help of traditional optimization tools. In some fields of application, as e.g. the fleet assignment problem of airlines, this procedure was successfully established 38 . In other fields, like production planning and control, this technique could not be successfully applied, although mathematical models do exist 47 . Dynamic programming was developed by Richard Bellman in the early1950s 4 and is a computational method to deal with multi-stage decision processes in a dynamic environment. In fact, decision-making under uncertainty was the original and intended application of this technique 46 . Dynamic programming usually refers to simplifying a decision by breaking it down into a sequence of decision steps over time. It starts solving all subproblems at the final stage and then uses the solution to recursively compute solutions for higher stages until the original problem at the root is solved eventually. For more information on solution approaches in the context of optimization under uncertainty we refer the reader to 19,52 and the references therein. Quantification of Variables and Constraints: The explicit quantification of variables and constraints allows to express many problems that cannot be modeled using classical modeling paradigms. Quantifiers are a powerful tools to model uncertainty or adversarial situations. For example, if a decision is based on a value that is not exactly known in advance, one might look for robust solutions that are valid for all possible values that might occur. As the efforts of extending languages with quantifiers have not only been made for linear programs in terms of QLPs and QIPs, we give an overview in the following, where we briefly sketch the achievements from other fields in this context. Boolean Satisfiablility (SAT) and Constraint Satisfaction (CSP): Many real-world problems are combinatorial search problems that can be represented in terms of decision variables and constraints. Besides integer programming (IP), boolean satisfiability problems (SAT) and constraint satisfaction problems (CSP) are very successful frameworks that are used to model and solve these problems. The SAT problem is one of the most important and extensively studied problems in computer science. Given a propositional boolean formula, the SAT problem asks for an assignment of variables such that the formula evaluates to true, or a proof that no such assignment exists 1,21 . SAT is one of the classic problems in computer science, it is of theoretical interest because it is the canonical NP-complete problem 28 (cf. Section 4.2 for details). Apart from its high theoretical relevance, SAT has many practical applications as e.g. model checking, design verification, or AI planning 27,44 . Integer Programming (IP) generalizes the standard SAT problem, by allowing the possible values for the variables to be chosen from an arbitrary finite set, and allowing the constraints to be arbitrary linear constraints rather than just clauses. Whereas the solution approaches for IPs often rely on LP-relaxations combined with branch-and-cut procedures to find optimal integer solutions, the core of most modern SAT solvers is the Davis-Putnam-Logemann-Loveland (DPLL) algorithm 30,31 , which is essentially a depth-first-search with some pruning techniques like unit propagation 68 , conflict-driven clause learning, and back- tracking 43 . The constraint satisfaction problem (CSP) also generalizes the standard SAT problem, by allowing the possible values for the variables to be chosen from an arbitrary finite set. Furthermore, the constraints are allowed to to be arbitrary constraints rather than just clauses or linear constraints and thus, CSP also generalizes IP. The CSP problem consists of a set of variables, each with a finite domain of values and a set of constraints on subsets of these variables. CSPs provide a general framework to express a wide variety of combinatorial search problems and they play an important role in many areas of computer science and artificial intelligence 23 . They also find their application in the Operations Research community in the context of Location Planning, Scheduling, Car Sequencing, Cutting Stock Problems, Vehicle Routing, Timetabeling, Rostering and many more 24 . SAT, CSP and the IP feasibility problem are three different paradigms to model and solve combinatorial search problems, and as each of the problem classes is NP-complete, they can be reduced among each others in polynomial time 13,66,70 . However, each paradigm has its strengths and weaknesses. Due to their complementary strengths, there is an increasing belief that hybrid methods may often perform better than pure methods. An approach to integrate techniques from constraint programming and (mixed-integer) programming in order to exploit the strengths of both fields, is the constraint integer programming framework SCIP. However, there are classes of problems containing uncertainty that cannot be expressed within these frameworks. QCSPs and QSAT, which are the quantified extensions of CSP and SAT and allow for universally quantified variables, make it possible to model such problems that contain uncertainty. As a result, these extensions have been attracting significant interest in recent years. In the following, we highlight the key ideas of both approaches and specify their basic solution strategies. Bibliography: 1 B. Aspvall, M. F. Plass, and R. E. Tarjan. A linear-time algorithm for testing the truth of certain quantified boolean formulas. Inf. Process. Lett., 8(3):121\u2013123, 1979. Erratum: Information Processing Letters 14(4): 195 (1982). 2 A. Atamt\u00fcrk and M. Zhang. Two-stage robust network flow and design under demand uncertainty. Operations Research, 55(4):662\u2013673, 2007. 3 E. M. L. Beale. On minimizing a convex function subject to linear inequalities. J. Roy. Statist. Soc. Ser. B., 17, 1955. 4 R. Bellman. Dynamic Programming. Princeton University Press, Princeton, NJ, USA, 1. edition, 1957. 5 A. Ben-Tal, D. den Hertog, A. De Waegenaere, B. Melenberg, and G. Rennen. Robust solutions of optimization problems affected by uncertain probabilities. Manage. Sci., 59(2):341\u2013 357, Feb. 2013. 6 A. Ben-Tal, L. El Ghaoui, and A. Nemirovski. Robust optimization. Princeton University Press, 2009. 7 A. Ben-Tal, A. Goryashko, E. Guslitzer, and A. Nemirovski. Adjustable robust solutions of uncertain linear programs. Mathematical Programming, 99(2):351\u2013376, Mar. 2004. 8 A. Ben-Tal and A. Nemirovski. Robust truss topology design via semidefinite programming, research report 4/95. In Optimization Laboratory, Faculty of Industrial Engineering and Management, Technion The Israel Institute of Technology, Technion City, Haifa 32000, 1995. 9 A. Ben-Tal and A. Nemirovski. Robust convex optimization. Mathematics of Operations Research, 23:769\u2013805, 1998. 10 A. Ben-Tal and A. Nemirovski. Robust solutions of uncertain linear programs. Operations Research Letters, 25:1\u201313, 1999. 11 A. Ben-Tal and A. Nemirovski. Robust solutions of linear programming problems contaminated with uncertain data. Mathematical Programming, 88:411\u2013424, 2000. 12 A. Ben-Tal and A. Nemirovski. Robust optimization - methodology and applications. Mathematical Programming, 92(3):453\u2013480, 2002. 13 H. Bennaceur. A comparison between sat and csp techniques. Constraints, 9(2):123\u2013138, Apr. 2004. 14 D. Bertsimas, D. B. Brown, and C. Caramanis. Theory and applications of robust optimization. SIAM Rev., 53(3):464\u2013501, Aug. 2011. 15 D. Bertsimas and M. Sim. Robust discrete optimization and network flows. Mathematical Programming, 98(1-3):49\u201371, 2003. 16 D. Bertsimas and M. Sim. The price of robustness. OperationsResearch, 52(1):35\u201353,2004. 17 D. Bertsimas and M. Sim. Robust Discrete Optimization Under Ellipsoidal Uncertainty Sets. 2004. 18 D. Bertsimas and A. Thiele. A robust optimization approach to supply chain management. In IPCO, pages 86\u2013100, 2004. 19 D. Bertsimas and A. Thiele. Robust and Data-Driven Optimization: Modern Decision-Making Under Uncertainty. In Tutorials on Operations Research, INFORMS, 2006. 20 H.-G. Beyer and B. Sendhoff. Robust optimization A comprehensive survey. Computer Methods in Applied Mechanics and Engineering, 196:3190\u20133218, 2007. 22 J. R. Birge and F. Louveaux. Introduction to stochastic programming. Springer series in operations research. Springer, New York, 1997. 23 F. B\u00f6rner, A. A. Bulatov, H. Chen, P. Jeavons, and A. A. Krokhin. The complexity of constraint satisfaction games and qcsp. Inf. Comput., 207(9):923\u2013944, 2009. 24 S.C. Brailsford, C.N. Potts and B.M. Smith. Constraintsatisfaction problems: Algorithms and applications. European Journal of Operational Research, 119(3):557\u2013581, 1999. 25 P. Brucker. Scheduling Algorithms. Springer, Secaucus, NJ, USA, 3rd edition, 2001. 26 A. Charnes and W. W. Cooper. Chance-Constrained programming. Management Science, 6(1):73\u201379, 1959. 27 K. Claessen, N. Ee \u0301n, M. Sheeran, N. S\u00f6rensson ,A. Voronov, K.Akesson. Sat-solving in practice, with a tutorial example from supervisory control. Discrete Event Dynamic Systems, 19(4):495\u2013524, 2009. 28 S. A. Cook. The complexity of theorem-proving procedures. In Proceedings of the third annual ACM symposium on Theory of computing, STOC \u201971, pages 151\u2013158, New York, NY, USA, 1971. ACM. 29 G. B. Dantzig. Linear programming under uncertainty. Management Science, 1(3-4):197\u2013 206, 1955. 30 M. Davis, G. Logemann, and D. W. Loveland. A machine program for theorem-proving. Commun. ACM, 5(7):394\u2013397, 1962. 31 M. Davis and H. Putnam. A computing procedure for quantification theory. Jounal of the ACM, 7(3):201\u2013215, 1960. 32 T. Ederer, U. Lorenz, A. Martin, and J. Wolf. Quantified linear programs: a computational study. Proc. of the 11th Ann. Europ. Symp. on Algorithms (ESA 2012), pp. 203\u2013214, 2011, Springer. 33 T. Ederer, U. Lorenz, T. Opfer, and J. Wolf. Modeling games with the help of quantified integer linear programs. In ACG, pages 270\u2013281, 2011. 34 P. Eirinakis, S. Ruggieri, K. Subramani,and P.J.Wojciechowski: Computational complexity of inclusion queries over polyhedral sets. In ISAIM, 2012. 35 R. Gerber, W. Pugh, and M. Saksena. Parametric dispatching of hard real-time tasks. IEEE Transactions on Computers, 44:471\u2013479, 1995. 36 L. E. Ghaoui and H. Lebret. Robust solutions to least-squares problems with uncertain data, 1997. 37 L.E. Ghaoui, F. Oustry and H. Lebret. Robust solutions to uncertain semidefinite programs. SIAM J. OPTIMIZATION, 9(1):33\u201352, 1998. 38 S. Grothklags. Fleet assignment with connection dependent ground times. In Proc. of the 11th Ann. Europ. Symp. on Algorithms (ESA 2003), pages 667\u2013678, 2003. 39 T. Huynh, L. Joskowicz, C. Lassez, and J.-L. Lassez. Reasoning about linear constraints using parametric queries. In FSTTCS, pages 1\u201320, 1990. 40 P. Kall and S. Wallace. Stochastic programming. Wiley-Interscience series in systems and optimization. Wiley, 1994. 42 U. Lorenz, A.Martin and J. Wolf. Polyhedral and algorithmic properties of quantified linear programs. In Proc. of the 18th Ann. Europ. Symp. on Algorithms (ESA 2011), pages 512\u2013523, 2010. 43 S. Malik and L. Zhang. Boolean satisfiability from theoretical hardness to practical success. Commun. ACM, 52(8):76\u201382, Aug. 2009. 44 J. Marques-Silva. Practical applications of boolean satisfiability. In Workshop on Discrete Event Systems (WODES). IEEE Press, 2008. 45 N. Megow and T. Vredeveld. Approximation results for preemtive stochastic online scheduling. Proc. of the 14th Ann. Europ. Symp. on Algorithms (ESA 2006, 2006). 46 C. H. Papadimitriou. Games against nature. J. Comput. Syst. Sci., 31(2):288\u2013301, 1985. 47 Y. Pochet and L. A. Wolsey. Production Planning by Mixed Integer Programming (Springer Series in Operations Research and Financial Engineering). Springer, Secaucus, NJ, USA, 2006. 48 A. Prekopa. Stochastic Programming. Mathematics and Its Applications. Springer, 1995. 49 J. Renegar. Some perturbation theory for linear programming. Mathematical Programming, 65:73\u201391, 1992. 50 S. Ruggieri, P. Eirinakis, K. Subramani, and P. J. Wojciechowski. On the complexity of quantified linear systems. Theor. Comput. Sci., 518:128\u2013134, 2014. 51 A.Ruszczyn \u0301ski and A. Shapiro. Stochastic Programming. Handbooks in operations research and management science. Elsevier, 2003. 52 N. V. Sahinidis. Optimization under uncertainty: State-of-the-art and opportunities. Computers and Chemical Engineering, 28:971\u2013983, 2004. 53 M. C. Saksena. Parametric Scheduling for Hard Real-time Systems. PhD thesis, College Park, MD, USA, 1994. 54 A. Schrijver. Theory of linear and integer programming. John Wiley and Sons, Inc., New York, NY, USA, 1986. 55 R. Schultz. Stochastic programming with integer variables. Math. Progr.,97:285\u2013309,2003. 56 S. Sen. Algorithms for Stochastic Mixed-Integer Programming Models. Handbooks in OR and MS. 57 A. L. Soyster. Convex Programming with Set-Inclusive Constraints and Applications to Inexact Linear Programming. Operations Research, 21(5):1154\u20131157, 1973. 58 K. Subramani. Parametric scheduling - algorithms and complexity. In HiPC, pages 36\u201346, 2001. 59 K. Subramani. A specification framework for real-time scheduling. In SOFSEM, pages 195\u2013207, 2002. 60 K. Subramani. Analyzing selected quantified integer programs. In IJCAR, pages 342\u2013356, 2004. 61 K.Subramani. Partially clair voyant scheduling for aggregate constraints. JAMDS,9(4):225\u2013 240, 2005. 62 A. Thiele, C. Murat, and V. Gabrel. Recent advances in robust optimization: An overview. European Journal of Operational Research, 2013. 63 M. H. van der Vlerk. Stochastic integer programming bibliography. World Wide Web, www.eco.rug.nl/mally/biblio/sip.html, 1996-2007. [Online; ac- cessed 1-July-2014]. 64 M. H. van der Vlerk. Stochastic programming bibliography. World Wide Web, http:// www.eco.rug.nl/mally/spbib.html, 1996-2007. [Online; accessed 1-July-2014]. 65 S. W. Wallace and W. T. Ziemba. Applications of Stochastic Programming. MPS-SIAM Series on Optimization. Society for Industrial and Applied Mathematics, 2005. 66 T. Walsh. Sat v csp. In R. Dechter, editor, CP, volume 1894 of Lecture Notes in Computer Science, pages 441\u2013456. Springer, 2000. 67 H.-X. Yu and L. Jin. An brief introduction to robust optimization approach. Int. J. Pure Appl. Math., 74(1):121\u2013124, 2012. 68 R. Zabih and D. A. McAllester. A rearrangement search strategy for determining propositional satisfiability. In H. E. Shrobe, T. M. Mitchell, and R. G. Smith, editors, AAAI, pages 155\u2013160. AAAI Press / The MIT Press, 1988. 69 L. Zhang, H. Hermanns, F. Eisenbrand, and D. Jansen. Flow faster: Efficient decision algorithms for probabilistic simulations. Logical Methods in Computer Science, 4(4), 2008. 70 N.-F. Zhou, M. Tsuru, and E. Nobuyama. A comparison of cp, ip, and sat solvers through a common interface. In Proceedings of the 2012 IEEE 24th International Conference on Tools with Artificial Intelligence - Volume 01, ICTAI \u201912, pages 41\u201348, Washington, DC, USA, 2012. IEEE Computer Society. Developers Ulf Lorenz , project head and main contributor Michael Hartisch , contributor math programming, main contact for user service Jan Wolf, main contributor for solver library Community Apps There is a growing number of third-party tools and apps developed for Yasol and QIP. We would like to thank all contributors! Their effort helped making our optimization framework more accessible. Converter for different file formats of quantified programs, by Niklas Lorenz. GitHub Julia/JuMP interface for the Yasol solver, by Hendrik Becker and Michael Hartisch. GitHub DFG Funding Advanced Algorithms and Heuristics for Solving Quantified Mixed - Integer Linear Programs Funded since 2018 Project Description: Traditionally, it is assumed that the inputs of optimization problems are predefined and well known at planning time. However, considering uncertainty in the planning process is an essential asset. There are various approaches in the literature, how to deal with these uncertainties, one possibility is the use of quantified mixed-integer linear programs.Quantified mixed-integer linear programs are mixed integer linear programs with variables being either existentially or universally quantified. They can be interpreted as two-person zero- sum games between an existential and a universal player on the one side, or multistage optimization problems under uncertainty on the other side. Solutions of quantified programs are so called winning strategies for the existential player that specify how to react on moves of the universal player \u2013 certain fixations of universally quantified variables \u2013 to certainly win the game.Long-term goal of our efforts is the development of a tool for solving quantified mixed-integer linear programs and its presentation to the the public, just in the spirit of Cplex, Gurobi or Scip. In the pursuit of this objective, we develop, refine and substantiate solution procedures for the mighty modeling tool of quantified mixed-integer linear programs, in order to apply it for practice relevant tasks. One step in this direction was to publish the solver Yasol, as far as it exists already. We hope and expect that the results of this project will have far-reaching impact for research, as well as for practical optimization applications. As a further significant modeling extension, we will allow the active interference of the uncertainty set.","title":"Credits"},{"location":"Credits/#credits","text":"","title":"Credits"},{"location":"Credits/#yasol-software","text":"(Ulf Lorenz, Jan. 2017) Yasol is a search based solver for so called 'Quantified mixed integer linear programs with minimax objective\u2018 (Q-MIP). The aim is to support optimization under uncertainty in a new way, based upon rigorous formal models of quantification and linear constraints. While the solver is new in the sense that there are no other Q-MIP solver at this time - Jan. 2017, most basic ingredients of Yasol are not new at all. The heart of the search algorithm is an arithmetic linear constraint database together with the Alphabeta-algorithm which has been successfully used in gaming programs like in chess programs since many years. In order to realize fast back-jumps as typically performed in SAT- and QBF- solvers, we have extended the Alphabeta-algorithm as roughly described in 7 . Yasol deals with constraint learning on the so called primal side as known from SAT- and QBF- solving, as well as with constraint learning on the so called dual side, as is known from Mathematical Programming. The most inspiring sources from our point of view are: 1 T. Achterberg: Constraint Integer Programming. Doctoral Thesis 2 T. Achterberg, T. Koch, A. Martin: Branching on History Information. ZIB-Report 02-32, Berlin, 2002 3 H. Crowder, E.L. Johnson, M. Padberg: Solving Large-Scale Zero-One Linear Programming Problems. Operations Research, 31:5, pp. 803-834, 1983 4 G. Gamrath, T. Koch, A. Martin, M. Miltenberger, D. Weninger: Progress in Presolving for Mixed Integer Programming. ZIB-Report 13-48, Berlin, 2013 5 N. S\u00f6rensson, N. Een: MiniSat v1.13 \u2013 A SAT Solver with Conflict-Clause Minimization. minisat.se/downloads/MiniSat_v1.13_short.pdf 6 F. Lonsing, A. Biere. DepQBF: A Dependency-Aware QBF Solver. JSAT 7(2-3), 71\u201376 (2010) 7 Thorsten Ederer, Michael Hartisch, Ulf Lorenz, Thomas Opfer, Jan Wolf. Yasol: An Open Source Solver for Quantified Mixed Integer Programs. ACG 2017: 224-233 8 J. Wolf: Quantified Linear Programming. Doctoral Thesis. 9 L. Zhang: Searching for truth: Techniques for Satisfiability of Boolean Formulas. Doctoral Thesis Special thanks go to Alexander Martin for many fruitful discussions and bringing the field of integer programming to my interest.","title":"Yasol software"},{"location":"Credits/#history-q-mip-and-others","text":"(Jan Wolf, Jan. 2017) QLP / QIP: In 53 a QLP formulation was used to model problems from the domain of real-time scheduling 25 , with the goal to reduce the inflexibility of static scheduling in hard real-time systems. One of the fundamental features of real-time systems is the uncertain nature of execution times of tasks and the presence of complex timing constraints among them. In traditional models variable execution times are modeled through fixed worst-case values and relationships are limited to those that can be represented by precedence graphs 58 . Using QLPs as modeling tool allows to schedule tasks with varying execution times, represented by universally quantified variables, and complex timing constraints among tasks described by linear constraints. In this context, a first polynomial time algorithm to solve QLPs based on quantifier elimination techniques was proposed in 35 for a restricted class of constraints 53 , which are a subset of totally unimodular constraint systems 54 . For arbitrary linear constraints the worst-case time complexity of the proposed algorithm is double exponential 39,54 . Subramani proposed a framework to formalize scheduling problems in real-time systems using QLPs in 59 . There he focussed on the variability in the execution times, complex relationships between tasks using arbitrary linear constraints and different scheduling schemes \u2013 static (98-QLPs), co-static (89-QLPs) or parametric (alternating quantifier changes) \u2013 depending on the information available when dispatching. A detailed introduction to QLPs and methodologies to solve them are available in 32,42,60 . QIPs were studied in 61 , where a number of special cases where analyzed from the perspective of computational complexity. In that paper the authors discussed conditions under which QIPs can be relaxed to QLPs without altering the solution space. Research in this context was also supported by the Deutsche Forschungsgemeinschaft (DFG). The DFG founded project \u201cErweiterung mathemtische Optimierungsmethoden zur L\u00f6sung PSPACE-vollst\u00e4ndiger Probleme mit Hilfe quantifizierter linearer Programme\u201d at TU Darmstadt dealt with the development of algorithms to solve QIPs based on extended LP- and QLP-techniques. The DFG founded Collaborative Research Centre (SFB) 805 \u201cSonderforschungsbereich 805 - Beherrschung von Unsicherheit in lasttragenden Systemen des Maschinenbaus\u201d at TU Darmstadt deals with the control of uncertainty in mechanical systems. In this context Q-MIPs have been used to model and optimize process chains under uncertainty. Also in the context of game modeling QIPs can be applied. In 33 the PSPACE-complete two-person game Gomoku was modeled with the help of an QIP formulation, in 42 the model was adopted to the PSPACE-complete two-person game Connect-6 resulting in a 0/1-QIP that was solved with an extended variant of the algorithm proposed in 32 . Recently, extensions of traditional QLPs were presented in 34 , where the standard quantification was extended to implications of quantified linear systems, called quantified linear implications (QLI). QLPs and QLIs that arise when universally quantified variables are unbounded were studied in 50 . Whereas in the above citations the focus was on analyzing various special cases of the general problem, with a view on subclasses that are tractable, our focus lies on general QLPs with two or multiple stages without any restrictions to the quantification sequence or the constraint system. Furthermore, our focus lies on QLP optimization problems, whereas the above citations consider quantified decision problems in general. Optimization Under Uncertainty: Optimization Under Uncertainty has experienced rapid development in both theory and practice from the very beginning in the 1950s, starting with the seminal works of Beale 3 , Dantzig 29 , Bellman 4 as well as Charnes and Cooper 26 . The particular importance of optimization under uncertainty was also demonstrated in the seminal paper by Ben-Tal and Nemirovski 11 , where they showed in a detailed computational study that even a small perturbation of the problem data can make the nominal optimal solution completely meaningless from a practical viewpoint. We quote from their case study: \u201cIn real-world applications of linear programming, one cannot ignore the possibility that a small uncertainty in the data can make the usual optimal solution completely meaningless from a practical viewpoint.\u201d Due to limited computational capabilities in the past, decision models often replaced those uncertainties with averages or best estimates but recent computational advantages greatly expanded the range of optimization techniques under uncertainty. Today stochastic programming and robust optimization \u2013 two fundamentally different approaches that address optimization with data uncertainty \u2013 are the most prominent modeling paradigms and presently the subject of intense research in this field. The main difference lies in the type of uncertainty that is handled by the two methodologies. Stochastic programming assumes the uncertainty to follow a probability distribution, while robust optimization in contrast is concerned with models that contain deterministic set-based uncertainties 14 . In the following we give a brief introduction to stochastic programming and robust optimization and compare them with quantified linear programming. Stochastic Programming: The approach for uncertainty quantification used in stochastic programming (see, e.g. 22,40,48,51 and the references therein) is the representation of random parameters in the input data (c, A, b) by random variables. This approach has a long and active history dating at least as far back as Dantzigs original paper 29 and draws upon a variety of traditional operations research techniques. During the last four decades a vast quantity of literature on the subject has appeared (see, e.g. 63,64 for a stochastic programming bibliography maintained by Maarten van der Vlerk). A variety of stochastic programming applications can be found in 65 . The underlying optimization problem can be a linear program, a (mixed) integer program, but also a nonlinear program. Usually, stochastic programming models are furthermore subdivided in recourse models and chance constraint models. Recourse Models The more important and widely studied case, where most of the applications reported in the literature belong to and which has strong similarities to QLPs, is that of a stochastic linear program with recourse, which first appeared in Beale 3 and Dantzig 29 . These problems arise when some of the decision variables must be taken before the outcomes of some (or all) random events are known, and some after they become known. Recourse variables represent decisions that can be made on a \u201cwait and see\u201d basis, after the uncertainty is resolved, and they allow to adapt a solution to the specific outcome observed. Stochastic programming problems with recourse can be essentially divided into two-stage and multi-stage problems (TSSLPs and MSSLPs). In the former, a set of initial decisions are taken first, followed by a random event. After this, recourse decisions, which are based on this event, are taken. The multi-stage problem, accordingly consists of multiple stages, with a random event occurring between each stage. Chance Constraints Models: The essence of recourse models is that infeasibilities in the second or higher stages are allowed and can be compensated at a certain penalty. In chance constraint models, developed by Charnes and Cooper 26 , the focus lies on the reliability of the system in contrast. This reliability is expressed as a minimum requirement on the probability of satisfying constraints. The resulting program is called a chance-constrained stochastic program. Under certain assumptions on the probability distribution (like e.g. Normal, Cauchy, Uniform), chance- constraints can be converted into a deterministic equivalent form and then be treated as in a traditional recourse problem as mentioned above. More details on chance-constrained stochastic programming can be found in 48 . Over the last 20 years, also stochastic programming with integer or binary recourse variables has received tremendous research attention in both application and algorithmic aspects. However, compared to the continuous case of a TSSLP or MSSLP, relatively little is known on theory and algorithms for linear mixed-integer stochastic programming in general. Given that duality results do not hold in general IP and MIP formulations, it is also difficult to extend current algorithms for the linear case in order to generate cutting planes, except when only the first stage contains integer variables or other special cases. A survey of developments can be found in 55,56 , a stochastic integer programming bibliography with publications from the years 1996-2007 can be found at 63 . Compared to stochastic programming models, a QLP can be interpreted as a worst-case MSSLP with fixed recourse and only the right-hand side being affected by uncertainties. The main advantage of quantified linear and integer programming is that uncertainty can be easily modeled without detailed knowledge of the underling probability distribution. Furthermore, while SP models minimize the expected value of an objective function with respect to a set of scenarios, QLPs minimize an objective function with respect to the possible worst case (maximum loss). There is a recursive node-based definition for QLPs, similar as for MSSLPs, and it has been shown how a DEP of a QLP can be constructed. Robust Optimization: In contrast to stochastic programming, robust optimization is a more recent approach in the context of optimization under uncertainty, in which the uncertainty model is not stochastic, but rather deterministic and set-based. Instead of seeking to immunize the solution in some probabilistic sense to stochastic uncertainty, here the decision-maker constructs a solution that is valid for any realization of uncertainty in a given set 14 . While applications of stochastic programming have been reported over many years in the literature, robust optimization appeared recently, with most research in the past ten years (see, e.g. 6,12,14,16,20,62 and the references therein). The roots can be found in the field of robust control and in the work of Soyster 57 . However, high interest in both theoretical aspects and practical applications started in the first place with the work of Ben-Tal and Nemirovski 8,9 , and El-Ghaoui et al 36,37 in the late 1990s. The idea of robust optimization is to define a so-called uncertanty set U for the uncertain parameters in the input data (c, A, b) and then to require that the constraint system should hold for any possible realization of the data from U. The optimization problem modeling this requirement is called the robust counterpart problem (RCP), an optimal solution of the RCP is called robust optimal solution. The robust optimization methodology can be applied to any optimization problem (e.g. quadratically constrained quadratic programs (QCQPs) or semidefinite programs (SDPs)), in which the uncertain data is known to lie in a given uncertainty set. Though it is still a relatively new approach, it has already proved very useful in many applications. In 6 a list of problem classes for which robust optimization is applicable is listed. One might imagine that the addition of robustness to a general optimization problem comes at the expense of a significantly increased computational complexity, and indeed, the RCP of an arbitrary convex optimization problem is in general intractable 6 . Nevertheless, depending on the structure of the underlying optimization problem and the uncertainty set U , the corresponding RCP can be solved or at least be approximated in polynomial time for many application cases 9 . Ben-Tal and Nemirovski 10 showed that the RCP of a linear optimization problem is essentially always tractable for many practical uncertainty sets. Due to the results in 6 , in the case of robust linear optimization, the objective and the right-hand side of the constraints can be assumed to be deterministic and w.l.o.g. constraint-wise uncertainty can be assumed. It hence suffices to focus on single constraints of a special form. These are referred as the subproblems which must be solved in order to solve the entire RCP. Of course, a major modeling decision concerns the choice of the uncertainty set U and the resulting RCP might not longer be an LP 5 . In particular, the RCP of an LP with a polyhedral uncertainty set becomes a linear programming problem, while the RCP of an LP with an ellipsoidal uncertainty set becomes a second-order cone problem respectively 12 . Other interesting results have been achieved recently, e.g. under very natural assumptions, robust LPs can be formulated as semi-definite programming problems and thus solved by a polynomial time approximation scheme 6,9 . Several attempts to extend the ideas to discrete robust optimization have been e.g. made in 15,17,18 . However, unlike the case of continuous robust optimization, the conditions on the uncertainty sets are rather restrictive to still ensure the efficient solvability of the RCP as shown in 17 . Therefore, approximation techniques based on piecewise linearization are currently the means of choice for such problems 20 . While stochastic programming problems can result in large deterministic linear models when considering many scenarios, the RCP models grow only slightly when uncertainty is added in general and therefore, they can often be solved efficiently. Another crucial difference is that in the stochastic programming approach constraints may be violated with a certain probability (chance-constraints) or at a given penalty (recourse model), whereas robust optimization is associated with hard constraints, which must be satisfied whatever the realization of the data (c, A, b) in the uncertainty set U is 10 . Thus, in many cases a single-stage robust optimization model tends to be to conservative 2 , especially in situations where some recourse decisions can be made after the uncertainty is revealed. To address this issue, two-stage models \u2013 also called robust adjustable or adaptable optimization \u2013 were proposed e.g. in 7 . However, two-stage problems are very challenging to compute, even formulations with LP problems in both stages can be NP-hard 7 . Nevertheless, in many real-world problems, decisions and uncertainty are often repeatedly interwoven over time and RO model are not capable to handle this efficiently due to the difficulty in incorporating multiple stages 62 . From the viewpoint of quantified linear and integer programming, robust optimization problems can be viewed as QLPs with one quantifier change (98), whereas in QLPs multiple quantifier changes occur in general. However, from the viewpoint of robust optimization, where arbitrary uncertainty sets may appear (though not necessarily being tractable at all), the uncertainty set of QLPs is a simple hyperrectangle. Other LP-based solution techniques: Apart from stochastic programming and robust optimization as mentioned above, typical solution approaches for problems that are affected by uncertainty are sensitivity analysis 49 , LP-based approximation techniques 45 , dynamic programming 4 , and the exploration of Markov-chains 69 for example. Sensitivity analysis is a simple classical method of addressing uncertainty, which is typically applied as a post-optimization tool for quantifying the goodness or robustness of a solution, e.g. the change in cost for small perturbations in the underlying problem data. It is not particularly helpful for generating solutions that are robust to data changes in the sense of an a priori ensured feasibility when the problem parameters vary within the prescribed uncertainty set 67 . A further possibility to deal with these uncertainties is an approximation where a given probability distribution is aggregated to a single estimated number. Then, the optimum concerning these estimated input data can be computed with the help of traditional optimization tools. In some fields of application, as e.g. the fleet assignment problem of airlines, this procedure was successfully established 38 . In other fields, like production planning and control, this technique could not be successfully applied, although mathematical models do exist 47 . Dynamic programming was developed by Richard Bellman in the early1950s 4 and is a computational method to deal with multi-stage decision processes in a dynamic environment. In fact, decision-making under uncertainty was the original and intended application of this technique 46 . Dynamic programming usually refers to simplifying a decision by breaking it down into a sequence of decision steps over time. It starts solving all subproblems at the final stage and then uses the solution to recursively compute solutions for higher stages until the original problem at the root is solved eventually. For more information on solution approaches in the context of optimization under uncertainty we refer the reader to 19,52 and the references therein. Quantification of Variables and Constraints: The explicit quantification of variables and constraints allows to express many problems that cannot be modeled using classical modeling paradigms. Quantifiers are a powerful tools to model uncertainty or adversarial situations. For example, if a decision is based on a value that is not exactly known in advance, one might look for robust solutions that are valid for all possible values that might occur. As the efforts of extending languages with quantifiers have not only been made for linear programs in terms of QLPs and QIPs, we give an overview in the following, where we briefly sketch the achievements from other fields in this context. Boolean Satisfiablility (SAT) and Constraint Satisfaction (CSP): Many real-world problems are combinatorial search problems that can be represented in terms of decision variables and constraints. Besides integer programming (IP), boolean satisfiability problems (SAT) and constraint satisfaction problems (CSP) are very successful frameworks that are used to model and solve these problems. The SAT problem is one of the most important and extensively studied problems in computer science. Given a propositional boolean formula, the SAT problem asks for an assignment of variables such that the formula evaluates to true, or a proof that no such assignment exists 1,21 . SAT is one of the classic problems in computer science, it is of theoretical interest because it is the canonical NP-complete problem 28 (cf. Section 4.2 for details). Apart from its high theoretical relevance, SAT has many practical applications as e.g. model checking, design verification, or AI planning 27,44 . Integer Programming (IP) generalizes the standard SAT problem, by allowing the possible values for the variables to be chosen from an arbitrary finite set, and allowing the constraints to be arbitrary linear constraints rather than just clauses. Whereas the solution approaches for IPs often rely on LP-relaxations combined with branch-and-cut procedures to find optimal integer solutions, the core of most modern SAT solvers is the Davis-Putnam-Logemann-Loveland (DPLL) algorithm 30,31 , which is essentially a depth-first-search with some pruning techniques like unit propagation 68 , conflict-driven clause learning, and back- tracking 43 . The constraint satisfaction problem (CSP) also generalizes the standard SAT problem, by allowing the possible values for the variables to be chosen from an arbitrary finite set. Furthermore, the constraints are allowed to to be arbitrary constraints rather than just clauses or linear constraints and thus, CSP also generalizes IP. The CSP problem consists of a set of variables, each with a finite domain of values and a set of constraints on subsets of these variables. CSPs provide a general framework to express a wide variety of combinatorial search problems and they play an important role in many areas of computer science and artificial intelligence 23 . They also find their application in the Operations Research community in the context of Location Planning, Scheduling, Car Sequencing, Cutting Stock Problems, Vehicle Routing, Timetabeling, Rostering and many more 24 . SAT, CSP and the IP feasibility problem are three different paradigms to model and solve combinatorial search problems, and as each of the problem classes is NP-complete, they can be reduced among each others in polynomial time 13,66,70 . However, each paradigm has its strengths and weaknesses. Due to their complementary strengths, there is an increasing belief that hybrid methods may often perform better than pure methods. An approach to integrate techniques from constraint programming and (mixed-integer) programming in order to exploit the strengths of both fields, is the constraint integer programming framework SCIP. However, there are classes of problems containing uncertainty that cannot be expressed within these frameworks. QCSPs and QSAT, which are the quantified extensions of CSP and SAT and allow for universally quantified variables, make it possible to model such problems that contain uncertainty. As a result, these extensions have been attracting significant interest in recent years. In the following, we highlight the key ideas of both approaches and specify their basic solution strategies. Bibliography: 1 B. Aspvall, M. F. Plass, and R. E. Tarjan. A linear-time algorithm for testing the truth of certain quantified boolean formulas. Inf. Process. Lett., 8(3):121\u2013123, 1979. Erratum: Information Processing Letters 14(4): 195 (1982). 2 A. Atamt\u00fcrk and M. Zhang. Two-stage robust network flow and design under demand uncertainty. Operations Research, 55(4):662\u2013673, 2007. 3 E. M. L. Beale. On minimizing a convex function subject to linear inequalities. J. Roy. Statist. Soc. Ser. B., 17, 1955. 4 R. Bellman. Dynamic Programming. Princeton University Press, Princeton, NJ, USA, 1. edition, 1957. 5 A. Ben-Tal, D. den Hertog, A. De Waegenaere, B. Melenberg, and G. Rennen. Robust solutions of optimization problems affected by uncertain probabilities. Manage. Sci., 59(2):341\u2013 357, Feb. 2013. 6 A. Ben-Tal, L. El Ghaoui, and A. Nemirovski. Robust optimization. Princeton University Press, 2009. 7 A. Ben-Tal, A. Goryashko, E. Guslitzer, and A. Nemirovski. Adjustable robust solutions of uncertain linear programs. Mathematical Programming, 99(2):351\u2013376, Mar. 2004. 8 A. Ben-Tal and A. Nemirovski. Robust truss topology design via semidefinite programming, research report 4/95. In Optimization Laboratory, Faculty of Industrial Engineering and Management, Technion The Israel Institute of Technology, Technion City, Haifa 32000, 1995. 9 A. Ben-Tal and A. Nemirovski. Robust convex optimization. Mathematics of Operations Research, 23:769\u2013805, 1998. 10 A. Ben-Tal and A. Nemirovski. Robust solutions of uncertain linear programs. Operations Research Letters, 25:1\u201313, 1999. 11 A. Ben-Tal and A. Nemirovski. Robust solutions of linear programming problems contaminated with uncertain data. Mathematical Programming, 88:411\u2013424, 2000. 12 A. Ben-Tal and A. Nemirovski. Robust optimization - methodology and applications. Mathematical Programming, 92(3):453\u2013480, 2002. 13 H. Bennaceur. A comparison between sat and csp techniques. Constraints, 9(2):123\u2013138, Apr. 2004. 14 D. Bertsimas, D. B. Brown, and C. Caramanis. Theory and applications of robust optimization. SIAM Rev., 53(3):464\u2013501, Aug. 2011. 15 D. Bertsimas and M. Sim. Robust discrete optimization and network flows. Mathematical Programming, 98(1-3):49\u201371, 2003. 16 D. Bertsimas and M. Sim. The price of robustness. OperationsResearch, 52(1):35\u201353,2004. 17 D. Bertsimas and M. Sim. Robust Discrete Optimization Under Ellipsoidal Uncertainty Sets. 2004. 18 D. Bertsimas and A. Thiele. A robust optimization approach to supply chain management. In IPCO, pages 86\u2013100, 2004. 19 D. Bertsimas and A. Thiele. Robust and Data-Driven Optimization: Modern Decision-Making Under Uncertainty. In Tutorials on Operations Research, INFORMS, 2006. 20 H.-G. Beyer and B. Sendhoff. Robust optimization A comprehensive survey. Computer Methods in Applied Mechanics and Engineering, 196:3190\u20133218, 2007. 22 J. R. Birge and F. Louveaux. Introduction to stochastic programming. Springer series in operations research. Springer, New York, 1997. 23 F. B\u00f6rner, A. A. Bulatov, H. Chen, P. Jeavons, and A. A. Krokhin. The complexity of constraint satisfaction games and qcsp. Inf. Comput., 207(9):923\u2013944, 2009. 24 S.C. Brailsford, C.N. Potts and B.M. Smith. Constraintsatisfaction problems: Algorithms and applications. European Journal of Operational Research, 119(3):557\u2013581, 1999. 25 P. Brucker. Scheduling Algorithms. Springer, Secaucus, NJ, USA, 3rd edition, 2001. 26 A. Charnes and W. W. Cooper. Chance-Constrained programming. Management Science, 6(1):73\u201379, 1959. 27 K. Claessen, N. Ee \u0301n, M. Sheeran, N. S\u00f6rensson ,A. Voronov, K.Akesson. Sat-solving in practice, with a tutorial example from supervisory control. Discrete Event Dynamic Systems, 19(4):495\u2013524, 2009. 28 S. A. Cook. The complexity of theorem-proving procedures. In Proceedings of the third annual ACM symposium on Theory of computing, STOC \u201971, pages 151\u2013158, New York, NY, USA, 1971. ACM. 29 G. B. Dantzig. Linear programming under uncertainty. Management Science, 1(3-4):197\u2013 206, 1955. 30 M. Davis, G. Logemann, and D. W. Loveland. A machine program for theorem-proving. Commun. ACM, 5(7):394\u2013397, 1962. 31 M. Davis and H. Putnam. A computing procedure for quantification theory. Jounal of the ACM, 7(3):201\u2013215, 1960. 32 T. Ederer, U. Lorenz, A. Martin, and J. Wolf. Quantified linear programs: a computational study. Proc. of the 11th Ann. Europ. Symp. on Algorithms (ESA 2012), pp. 203\u2013214, 2011, Springer. 33 T. Ederer, U. Lorenz, T. Opfer, and J. Wolf. Modeling games with the help of quantified integer linear programs. In ACG, pages 270\u2013281, 2011. 34 P. Eirinakis, S. Ruggieri, K. Subramani,and P.J.Wojciechowski: Computational complexity of inclusion queries over polyhedral sets. In ISAIM, 2012. 35 R. Gerber, W. Pugh, and M. Saksena. Parametric dispatching of hard real-time tasks. IEEE Transactions on Computers, 44:471\u2013479, 1995. 36 L. E. Ghaoui and H. Lebret. Robust solutions to least-squares problems with uncertain data, 1997. 37 L.E. Ghaoui, F. Oustry and H. Lebret. Robust solutions to uncertain semidefinite programs. SIAM J. OPTIMIZATION, 9(1):33\u201352, 1998. 38 S. Grothklags. Fleet assignment with connection dependent ground times. In Proc. of the 11th Ann. Europ. Symp. on Algorithms (ESA 2003), pages 667\u2013678, 2003. 39 T. Huynh, L. Joskowicz, C. Lassez, and J.-L. Lassez. Reasoning about linear constraints using parametric queries. In FSTTCS, pages 1\u201320, 1990. 40 P. Kall and S. Wallace. Stochastic programming. Wiley-Interscience series in systems and optimization. Wiley, 1994. 42 U. Lorenz, A.Martin and J. Wolf. Polyhedral and algorithmic properties of quantified linear programs. In Proc. of the 18th Ann. Europ. Symp. on Algorithms (ESA 2011), pages 512\u2013523, 2010. 43 S. Malik and L. Zhang. Boolean satisfiability from theoretical hardness to practical success. Commun. ACM, 52(8):76\u201382, Aug. 2009. 44 J. Marques-Silva. Practical applications of boolean satisfiability. In Workshop on Discrete Event Systems (WODES). IEEE Press, 2008. 45 N. Megow and T. Vredeveld. Approximation results for preemtive stochastic online scheduling. Proc. of the 14th Ann. Europ. Symp. on Algorithms (ESA 2006, 2006). 46 C. H. Papadimitriou. Games against nature. J. Comput. Syst. Sci., 31(2):288\u2013301, 1985. 47 Y. Pochet and L. A. Wolsey. Production Planning by Mixed Integer Programming (Springer Series in Operations Research and Financial Engineering). Springer, Secaucus, NJ, USA, 2006. 48 A. Prekopa. Stochastic Programming. Mathematics and Its Applications. Springer, 1995. 49 J. Renegar. Some perturbation theory for linear programming. Mathematical Programming, 65:73\u201391, 1992. 50 S. Ruggieri, P. Eirinakis, K. Subramani, and P. J. Wojciechowski. On the complexity of quantified linear systems. Theor. Comput. Sci., 518:128\u2013134, 2014. 51 A.Ruszczyn \u0301ski and A. Shapiro. Stochastic Programming. Handbooks in operations research and management science. Elsevier, 2003. 52 N. V. Sahinidis. Optimization under uncertainty: State-of-the-art and opportunities. Computers and Chemical Engineering, 28:971\u2013983, 2004. 53 M. C. Saksena. Parametric Scheduling for Hard Real-time Systems. PhD thesis, College Park, MD, USA, 1994. 54 A. Schrijver. Theory of linear and integer programming. John Wiley and Sons, Inc., New York, NY, USA, 1986. 55 R. Schultz. Stochastic programming with integer variables. Math. Progr.,97:285\u2013309,2003. 56 S. Sen. Algorithms for Stochastic Mixed-Integer Programming Models. Handbooks in OR and MS. 57 A. L. Soyster. Convex Programming with Set-Inclusive Constraints and Applications to Inexact Linear Programming. Operations Research, 21(5):1154\u20131157, 1973. 58 K. Subramani. Parametric scheduling - algorithms and complexity. In HiPC, pages 36\u201346, 2001. 59 K. Subramani. A specification framework for real-time scheduling. In SOFSEM, pages 195\u2013207, 2002. 60 K. Subramani. Analyzing selected quantified integer programs. In IJCAR, pages 342\u2013356, 2004. 61 K.Subramani. Partially clair voyant scheduling for aggregate constraints. JAMDS,9(4):225\u2013 240, 2005. 62 A. Thiele, C. Murat, and V. Gabrel. Recent advances in robust optimization: An overview. European Journal of Operational Research, 2013. 63 M. H. van der Vlerk. Stochastic integer programming bibliography. World Wide Web, www.eco.rug.nl/mally/biblio/sip.html, 1996-2007. [Online; ac- cessed 1-July-2014]. 64 M. H. van der Vlerk. Stochastic programming bibliography. World Wide Web, http:// www.eco.rug.nl/mally/spbib.html, 1996-2007. [Online; accessed 1-July-2014]. 65 S. W. Wallace and W. T. Ziemba. Applications of Stochastic Programming. MPS-SIAM Series on Optimization. Society for Industrial and Applied Mathematics, 2005. 66 T. Walsh. Sat v csp. In R. Dechter, editor, CP, volume 1894 of Lecture Notes in Computer Science, pages 441\u2013456. Springer, 2000. 67 H.-X. Yu and L. Jin. An brief introduction to robust optimization approach. Int. J. Pure Appl. Math., 74(1):121\u2013124, 2012. 68 R. Zabih and D. A. McAllester. A rearrangement search strategy for determining propositional satisfiability. In H. E. Shrobe, T. M. Mitchell, and R. G. Smith, editors, AAAI, pages 155\u2013160. AAAI Press / The MIT Press, 1988. 69 L. Zhang, H. Hermanns, F. Eisenbrand, and D. Jansen. Flow faster: Efficient decision algorithms for probabilistic simulations. Logical Methods in Computer Science, 4(4), 2008. 70 N.-F. Zhou, M. Tsuru, and E. Nobuyama. A comparison of cp, ip, and sat solvers through a common interface. In Proceedings of the 2012 IEEE 24th International Conference on Tools with Artificial Intelligence - Volume 01, ICTAI \u201912, pages 41\u201348, Washington, DC, USA, 2012. IEEE Computer Society.","title":"History: Q-MIP and others"},{"location":"Credits/#developers","text":"Ulf Lorenz , project head and main contributor Michael Hartisch , contributor math programming, main contact for user service Jan Wolf, main contributor for solver library","title":"Developers"},{"location":"Credits/#community-apps","text":"There is a growing number of third-party tools and apps developed for Yasol and QIP. We would like to thank all contributors! Their effort helped making our optimization framework more accessible. Converter for different file formats of quantified programs, by Niklas Lorenz. GitHub Julia/JuMP interface for the Yasol solver, by Hendrik Becker and Michael Hartisch. GitHub","title":"Community Apps"},{"location":"Credits/#dfg-funding","text":"Advanced Algorithms and Heuristics for Solving Quantified Mixed - Integer Linear Programs Funded since 2018 Project Description: Traditionally, it is assumed that the inputs of optimization problems are predefined and well known at planning time. However, considering uncertainty in the planning process is an essential asset. There are various approaches in the literature, how to deal with these uncertainties, one possibility is the use of quantified mixed-integer linear programs.Quantified mixed-integer linear programs are mixed integer linear programs with variables being either existentially or universally quantified. They can be interpreted as two-person zero- sum games between an existential and a universal player on the one side, or multistage optimization problems under uncertainty on the other side. Solutions of quantified programs are so called winning strategies for the existential player that specify how to react on moves of the universal player \u2013 certain fixations of universally quantified variables \u2013 to certainly win the game.Long-term goal of our efforts is the development of a tool for solving quantified mixed-integer linear programs and its presentation to the the public, just in the spirit of Cplex, Gurobi or Scip. In the pursuit of this objective, we develop, refine and substantiate solution procedures for the mighty modeling tool of quantified mixed-integer linear programs, in order to apply it for practice relevant tasks. One step in this direction was to publish the solver Yasol, as far as it exists already. We hope and expect that the results of this project will have far-reaching impact for research, as well as for practical optimization applications. As a further significant modeling extension, we will allow the active interference of the uncertainty set.","title":"DFG Funding"},{"location":"Download/","text":"Download Solver for Quantified Mixed Integer Programs Since Yasol has no own built-in LP solver you either need to install IBM\u00ae ILOG\u00ae CPLEX\u00ae Optimization Studio or the COIN-OR Optimization Suite in order to use our solver. Our solver makes intensive use of their linear program solver. These tools are black-box used, but it is our intention not to use the integer solving abilities of these foreign solvers. You can download the source code and build the project using the provided batch files for the following operating systems: Mac OS Linux Windows QMIP Instances in the QLP File Format In order to solve Q-MIPs with Yasol, the instances have to be available in QLP file format. We provide a number of test instances . Getting started on Windows Since Yasol has no own built-in LP solver you either need to install IBM\u00ae ILOG\u00ae CPLEX\u00ae Optimization Studio or the COIN-OR Optimization Suite in order to use our solver. For download- and license information of these extern tools, we refer to the corresponding webpages of CPLEX\u00ae and Coin-OR . In order to execute our batch file that builds the project your systems must be able to run makefiles. One possible way of doing so is to use the Developer Command Prompt , which is accessible if you are using Microsoft Visual Studio. In order to use Yasol on Windows you need to perform the following steps: Download the current Yasol version (3.9.9.3.1 from 2020; the latest version from 2023 is currently only available for Mac and linux) and unpack it ( Download ). Open the x64 Developer Command Prompt. change your directory to the Yasol main folder. Provide the location of your compiler by setting the variable CC. We recommend clang++. This might look like set CC=\"C:/Program Files/LLVM/bin/clang++\" Provide your folder containing COIN OR (CPLEX) by setting the variable YASOL_CLP_PATH (YASOL_CPLEX_PATH). This might look like set YASOL_CPLEX_PATH=\"C:/Program Files/IBM/ILOG/CPLEX_Studio1261/cplex\" set YASOL_CLP_PATH=\"C:/Program Files/Cbc-2.9.0\" Execute the batch file build_clp (build_cplex) which you should find in the main folder. This will build the executable Yasol_CLP (Yasol_CPLEX) in the subdirectory /bin. If you want to build both you can run 'build_all'. In ordern to solve a .qlp instance execute YASOL_CLP (YASOL_CPLEX) with the qlp file you want to solve as input parameters, for example: Yasol_CLP ../../../Data/p2756.qlp Executable: For Windows users we also provide an executable version which uses Coin Or. Older Versions (Yasol_O-1.3.3(2017)): Windows Sources: Download Windows Executable: Download Getting started on Mac OS and Linux Since Yasol has no own built-in LP solver you either need to install IBM\u00ae ILOG\u00ae CPLEX\u00ae Optimization Studio or the COIN-OR Optimization Suite in order to use our solver. For download- and license information of these extern tools, we refer to the corresponding webpages of CPLEX\u00ae and Coin-OR . In order to use Yasol on Mac or Linux you need to perform the following steps: Download the latest Yasol version (4.0.1.5 from 2023) and unpack it (Mac: Download , Linux: Download ) Read the README and edit the respective entries in \"build_Yasol.bat\" to specify your system settings and in particular the location of your COIN OR or CPLEX distribution by setting the variables YASOL_CLP_PATH or YASOL_CPLEX_PATH, respectively. This might look like: export YASOL_CLP_PATH=/opt/tools/coinor_tool export YASOL_CPLEX_PATH=/opt/ibm/ILOG/CPLEX_Studio1261/cplex Make sure that this path contains the folders 'include' and 'lib'. Execute build_Yasol.bat. This will build the executable \"Yasol\" in the subdirectory Yasol/Debug. In order to execute Yasol using CLP from COIN OR as lp solver you might have to add the library location to your library search path variable: Mac: export DYLD_LIBRARY_PATH=$YASOL_CLP_PATH/lib:$DYLD_LIBRARY_PATH Linux: export LD_LIBRARY_PATH=$YASOL_CLP_PATH/lib:$LD_LIBRARY_PATH In ordern to solve a .qlp instance execute Yasol with the qlp file you want to solve as input parameters, for example: ./Yasol FirstInstances/Runway.qlp Futher remarks: Be sure that the file is in the .qlp format. For closer details on the file format examine the QLP file format . Always feel free to reach out to us. Setting up new software can be a tedious task and we are happy to help. You find our direct contact on our developers page Older versions: Yasol_3.9.9.3.1(2020): Mac: Download Linux: Download Yasol_O-1.3.3(2017): Mac: Download Linux: Download Known Bugs Displays result 'infeasible' even solution was found: Even though a solution is found during the search the final result is '-2.30584e+18', indicating an infeasible instance. However, the optimal solution value can be retrieved from the log. Happens more frequently on very small instances. When using CoinOR Tools as LP Solver, in case of a non simply restricted instance two additional IP (CBC) solvers are created. We have observed issues with these solvers that found IPs to be infeasible, even though they are not. This resulted in a thrown assertion or a wrong result. Happens more frequently on very small instances. License Licence statement The source code of Yasol that you find here on the download page is licensed under MIT license and the copyrights of the files are file dependent. Please note that library or object-files may be supplied under other license agreements. The MIT Licence states as follows: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Download"},{"location":"Download/#download","text":"","title":"Download"},{"location":"Download/#solver-for-quantified-mixed-integer-programs","text":"Since Yasol has no own built-in LP solver you either need to install IBM\u00ae ILOG\u00ae CPLEX\u00ae Optimization Studio or the COIN-OR Optimization Suite in order to use our solver. Our solver makes intensive use of their linear program solver. These tools are black-box used, but it is our intention not to use the integer solving abilities of these foreign solvers. You can download the source code and build the project using the provided batch files for the following operating systems: Mac OS Linux Windows","title":"Solver for Quantified Mixed Integer Programs"},{"location":"Download/#qmip-instances-in-the-qlp-file-format","text":"In order to solve Q-MIPs with Yasol, the instances have to be available in QLP file format. We provide a number of test instances .","title":"QMIP Instances in the QLP File Format"},{"location":"Download/#getting-started-on-windows","text":"Since Yasol has no own built-in LP solver you either need to install IBM\u00ae ILOG\u00ae CPLEX\u00ae Optimization Studio or the COIN-OR Optimization Suite in order to use our solver. For download- and license information of these extern tools, we refer to the corresponding webpages of CPLEX\u00ae and Coin-OR . In order to execute our batch file that builds the project your systems must be able to run makefiles. One possible way of doing so is to use the Developer Command Prompt , which is accessible if you are using Microsoft Visual Studio. In order to use Yasol on Windows you need to perform the following steps: Download the current Yasol version (3.9.9.3.1 from 2020; the latest version from 2023 is currently only available for Mac and linux) and unpack it ( Download ). Open the x64 Developer Command Prompt. change your directory to the Yasol main folder. Provide the location of your compiler by setting the variable CC. We recommend clang++. This might look like set CC=\"C:/Program Files/LLVM/bin/clang++\" Provide your folder containing COIN OR (CPLEX) by setting the variable YASOL_CLP_PATH (YASOL_CPLEX_PATH). This might look like set YASOL_CPLEX_PATH=\"C:/Program Files/IBM/ILOG/CPLEX_Studio1261/cplex\" set YASOL_CLP_PATH=\"C:/Program Files/Cbc-2.9.0\" Execute the batch file build_clp (build_cplex) which you should find in the main folder. This will build the executable Yasol_CLP (Yasol_CPLEX) in the subdirectory /bin. If you want to build both you can run 'build_all'. In ordern to solve a .qlp instance execute YASOL_CLP (YASOL_CPLEX) with the qlp file you want to solve as input parameters, for example: Yasol_CLP ../../../Data/p2756.qlp Executable: For Windows users we also provide an executable version which uses Coin Or. Older Versions (Yasol_O-1.3.3(2017)): Windows Sources: Download Windows Executable: Download","title":"Getting started on Windows"},{"location":"Download/#getting-started-on-mac-os-and-linux","text":"Since Yasol has no own built-in LP solver you either need to install IBM\u00ae ILOG\u00ae CPLEX\u00ae Optimization Studio or the COIN-OR Optimization Suite in order to use our solver. For download- and license information of these extern tools, we refer to the corresponding webpages of CPLEX\u00ae and Coin-OR . In order to use Yasol on Mac or Linux you need to perform the following steps: Download the latest Yasol version (4.0.1.5 from 2023) and unpack it (Mac: Download , Linux: Download ) Read the README and edit the respective entries in \"build_Yasol.bat\" to specify your system settings and in particular the location of your COIN OR or CPLEX distribution by setting the variables YASOL_CLP_PATH or YASOL_CPLEX_PATH, respectively. This might look like: export YASOL_CLP_PATH=/opt/tools/coinor_tool export YASOL_CPLEX_PATH=/opt/ibm/ILOG/CPLEX_Studio1261/cplex Make sure that this path contains the folders 'include' and 'lib'. Execute build_Yasol.bat. This will build the executable \"Yasol\" in the subdirectory Yasol/Debug. In order to execute Yasol using CLP from COIN OR as lp solver you might have to add the library location to your library search path variable: Mac: export DYLD_LIBRARY_PATH=$YASOL_CLP_PATH/lib:$DYLD_LIBRARY_PATH Linux: export LD_LIBRARY_PATH=$YASOL_CLP_PATH/lib:$LD_LIBRARY_PATH In ordern to solve a .qlp instance execute Yasol with the qlp file you want to solve as input parameters, for example: ./Yasol FirstInstances/Runway.qlp Futher remarks: Be sure that the file is in the .qlp format. For closer details on the file format examine the QLP file format . Always feel free to reach out to us. Setting up new software can be a tedious task and we are happy to help. You find our direct contact on our developers page Older versions: Yasol_3.9.9.3.1(2020): Mac: Download Linux: Download Yasol_O-1.3.3(2017): Mac: Download Linux: Download","title":"Getting started on Mac OS and Linux"},{"location":"Download/#known-bugs","text":"Displays result 'infeasible' even solution was found: Even though a solution is found during the search the final result is '-2.30584e+18', indicating an infeasible instance. However, the optimal solution value can be retrieved from the log. Happens more frequently on very small instances. When using CoinOR Tools as LP Solver, in case of a non simply restricted instance two additional IP (CBC) solvers are created. We have observed issues with these solvers that found IPs to be infeasible, even though they are not. This resulted in a thrown assertion or a wrong result. Happens more frequently on very small instances.","title":"Known Bugs"},{"location":"Download/#license","text":"Licence statement The source code of Yasol that you find here on the download page is licensed under MIT license and the copyrights of the files are file dependent. Please note that library or object-files may be supplied under other license agreements. The MIT Licence states as follows: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"Instances/","text":"Instances Test instances The here provided are instances are formatted in the qlp file format. Note that in some instances universally quantified constraints are still indicated by a constraint name starting with \"U_\", rather than using the keyword UNCERTAINTY SUBJECT TO. When creating new instance always use the keyword. Artificial QIP instances Quantified Integeger Programs (QIP) are Q-MIPs with only integer variables. A special case of QIPs are Quantified Boolean Programs (QBP) with only boolean variables. The constraints are linear and an objective typically exists. QIP test instances Multistage Robust Selection Problem The task is to select p out of \\(n=2p\\) items, such that the costs are minimized 1, 2 . This happens in a multistage manner: In a first (existential) decision stage items can be selected for fixed costs. Then, in a universal decision stage, one of N cost scenario is selected and in the subsequent existential decision stage further items can be selected. Those two stages (disclosure of a scenario and selection of items) are repeated \\(S\\) times. We provide two different quantified models: a standard QIP and a QIP with universal constraints, i.e. a QIP with polyhedral uncertainty set. Selection instances have the naming scheme selection-n-p-N-S-R-t.qlp. \\(R\\) is the seed for the random number generator. \\(t\\in\\left\\{s,u\\right\\}\\) represents the model type: \\(s\\) for \"standard QIP\" and \\(u\\) for \"QIP with universal constraints\". We provide the following testsets: \\(N=4, n\\in\\left\\{10,20,30,40,50\\right\\}~ \\text{and}~ S \\in \\left\\{1,... ,8\\right\\}\\) (50 instances per constellation): Download: 2000 QIP instances Download: 2000 QIP instances with universal constrains \\(n=10, N=2^k, k \\in \\left\\{1,...,8\\right\\}~ \\text{and}~ S=s \\in \\left\\{1,...,8\\right\\} ~\\text{with}~ k+s\\leq 11\\) (50 instances per constellation): Download: 2450 QIP instances Download: 2450 QIP instances with universal constrains Multistage Robust Assignment Problem For a weighted bipartite graph \\(G=(V,E,c)\\) with \\(V=A\\cup B\\) , \\(n=\\left |A \\right| =\\left|B\\right|\\) one wants to determine a perfect matching of minimum costs 1, 2 . Similar to the selection problem, this happens in a multistage manner: In a first (existential) decision stage edges can be selected for fixed costs. Then, in a universal decision stage, one of \\(N\\) cost scenario is selected and in the subsequent existential decision stage further edges can be selected. Those two stages (disclosure of a scenario and selection of edges) are repeated \\(S\\) times. Again, we provide two different quantified models: a standard QIP and a QIP with universal constraints. Assignment instances have the naming scheme selection-n-N-S-R-t.qlp. \\(R\\) is the seed for the random number generator. $t \\in \\left{s,u\\right} represents the model type: \\(s\\) for \"standard QIP\" and \\(u\\) for \"QIP with universal constraints\". We provide the following testset: \\(n \\in \\left\\{4,5,6,7,8,9,10\\right\\}, N \\in \\left\\{2,4,8\\right\\} ~\\text{and}~ S \\in \\left\\{1,2,3,4\\right\\}\\) (50 instances per constellation): Download: 4200 QIP instances Download: 4200 QIP instances with universal constrains Multistage Robust Lot-Sizing Problem We consider a single item lot-sizing problem with discrete ordering decisions and \\(T\\) periods 2 . At the beginning of each time period, the product demand that needs to be satisfied is disclosed: Either \\(dt\\) or \\(dt\\) . In order to serve the demand, in each period \\(t \\in \\left\\{0,...,T-1\\right\\}\\) one of \\(B\\) basic orders can be places resulting in the deliverance of corresponding quantity at the beginning of the subsequent period. Additionally, on of \\(U\\) urgent orders can be placed in each period \\(t\\in\\left\\{1,...,T\\right\\}\\) (with higher costs than the basic order), that is delivered in the same period. If the available quantity exceeds the demand, excess units are stored. Lot-Sizing instances have the naming scheme LotSizing-T-B-U-T.qlp. \\(R\\) is the seed for the random number generator. We provide the following testset: \\(T \\in \\left\\{5,6,7,8,9,10\\right\\}, B \\in \\left\\{3,4\\right\\} ~\\text{and}~ U \\in \\left\\{2,3\\right\\}\\) (50 instances per constellation): Download: 1200 QIP instances Multistage Robust Knapsack Problem The task is to find a valid knapsack solution for each of \\(T\\) stages with \\(n\\) available items, where uncertainty in the item weights has been added 2 . The number of items with increased weight is budgeted: in each time step the weight of at most \\(\\alpha\\) items can be increased and overall at most \\(\\beta\\) such increases are allowed. The objective ist to maximize the profit resulting from the selected knapsack items but additionally a transition bonus is used to aim for a stable sequence of solutions. Knapsack instances have the naming scheme Knapsack_T-n-R.qlp. \\(R\\) is the seed for the random number generator. We provide the following testset: \\(n\\in \\left\\{2,...,7\\right\\} ~\\text{and}~ T\\in\\left\\{2,...,7\\right\\}\\) (50 instances per constellation): Download: 1800 QIP instances Runway Scheduling Instances For a set of airplanes \\(A\\) , a set of timeslots \\(S\\) , and \\(b\\) runways we are interested in a \\(b\\) -matching such that each airplane is assigned to exactly one time slot and each time slot contains at most \\(b\\) airplanes 1 . After an initial plan is determined, the time windows (a set of time slots) for a (sub)set of airplanes are disclosed. These airplanes must be assigned to their final time slot (within the given time window). This happens in a multistage manner with \\(s\\) being the number of disclosures, i.e. the number of universal variable blocks, e.g. \\(s=2\\) stands for the quantification sequence \\(\\exists~\\forall~\\exists~\\forall~\\exists\\) . The universal player is restricted in the way she is allowed to select the time windows: the overall time window lengths must exceed a given value. This can be modeled either explicitly by using universal constraints or implicitly by adding variables and constraint that detect and penalize such a violation. For a more thorough introduction we refer to this Ph.D. thesis 1 . Runway scheduling instances have the naming scheme RWS-|A|-b-|S|-s-R-t.qlp. Again, \\(R\\) is the seed for the random number generator. \\(t\\in\\left\\{s,u\\right\\}\\) represents the model type: \\(s\\) for \"standard QIP\" and \\(u\\) for \"QIP with universal constraints\". We provide the following testsets: \\(\\left|A\\right|\\in\\left\\{2,...,8\\right\\}, \\left|S\\right|\\in\\left\\{3,...,10\\right\\}, b\\in\\left\\{2,3,4\\right\\} ~\\text{with}~ s=1\\) (20 instances per constellation): Download: 3360 QIP instances Download: 3360 QIP instances with universal constrains \\(\\left|A\\right|=7, \\left|S\\right|=12, b=3 ~\\text{and}~ s\\in\\left\\{1,..,4\\right\\}\\) (300 instances per constellation): Download: 1200 QIP instances Download: 1200 QIP instances with universal constrains Other instances The Quantified Satisfiability problem (QSAT), which is also know as the satisfiability of Quantified Boolean Formulas (QBF), is related to the Q-MIP-problem. In QSAT there is no objective function and all variables are binary. Further, it deals with clauses instead of arithmetic linear inequalities. However, with some effort and good will, it is possible to extract very special QMIPs from QSAT instances. Similar is the situation with MIPs, which deal with linear constraints but without quantification. Here, we present some further examples from these two sub-disciplines, collected from qbflib.org and miplib and converted to QLP-format. Instance collection IP based Instance collection MIP based Instance collection QBF based Please note that not all instances have been converted 1:1 due to some border cases in the conversion. 1 Further details can be found in this Ph.D. thesis 2 Further details can be found in this paper","title":"Instances"},{"location":"Instances/#instances","text":"","title":"Instances"},{"location":"Instances/#test-instances","text":"The here provided are instances are formatted in the qlp file format. Note that in some instances universally quantified constraints are still indicated by a constraint name starting with \"U_\", rather than using the keyword UNCERTAINTY SUBJECT TO. When creating new instance always use the keyword.","title":"Test instances"},{"location":"Instances/#artificial-qip-instances","text":"Quantified Integeger Programs (QIP) are Q-MIPs with only integer variables. A special case of QIPs are Quantified Boolean Programs (QBP) with only boolean variables. The constraints are linear and an objective typically exists. QIP test instances","title":"Artificial QIP instances"},{"location":"Instances/#multistage-robust-selection-problem","text":"The task is to select p out of \\(n=2p\\) items, such that the costs are minimized 1, 2 . This happens in a multistage manner: In a first (existential) decision stage items can be selected for fixed costs. Then, in a universal decision stage, one of N cost scenario is selected and in the subsequent existential decision stage further items can be selected. Those two stages (disclosure of a scenario and selection of items) are repeated \\(S\\) times. We provide two different quantified models: a standard QIP and a QIP with universal constraints, i.e. a QIP with polyhedral uncertainty set. Selection instances have the naming scheme selection-n-p-N-S-R-t.qlp. \\(R\\) is the seed for the random number generator. \\(t\\in\\left\\{s,u\\right\\}\\) represents the model type: \\(s\\) for \"standard QIP\" and \\(u\\) for \"QIP with universal constraints\". We provide the following testsets: \\(N=4, n\\in\\left\\{10,20,30,40,50\\right\\}~ \\text{and}~ S \\in \\left\\{1,... ,8\\right\\}\\) (50 instances per constellation): Download: 2000 QIP instances Download: 2000 QIP instances with universal constrains \\(n=10, N=2^k, k \\in \\left\\{1,...,8\\right\\}~ \\text{and}~ S=s \\in \\left\\{1,...,8\\right\\} ~\\text{with}~ k+s\\leq 11\\) (50 instances per constellation): Download: 2450 QIP instances Download: 2450 QIP instances with universal constrains","title":"Multistage Robust Selection Problem"},{"location":"Instances/#multistage-robust-assignment-problem","text":"For a weighted bipartite graph \\(G=(V,E,c)\\) with \\(V=A\\cup B\\) , \\(n=\\left |A \\right| =\\left|B\\right|\\) one wants to determine a perfect matching of minimum costs 1, 2 . Similar to the selection problem, this happens in a multistage manner: In a first (existential) decision stage edges can be selected for fixed costs. Then, in a universal decision stage, one of \\(N\\) cost scenario is selected and in the subsequent existential decision stage further edges can be selected. Those two stages (disclosure of a scenario and selection of edges) are repeated \\(S\\) times. Again, we provide two different quantified models: a standard QIP and a QIP with universal constraints. Assignment instances have the naming scheme selection-n-N-S-R-t.qlp. \\(R\\) is the seed for the random number generator. $t \\in \\left{s,u\\right} represents the model type: \\(s\\) for \"standard QIP\" and \\(u\\) for \"QIP with universal constraints\". We provide the following testset: \\(n \\in \\left\\{4,5,6,7,8,9,10\\right\\}, N \\in \\left\\{2,4,8\\right\\} ~\\text{and}~ S \\in \\left\\{1,2,3,4\\right\\}\\) (50 instances per constellation): Download: 4200 QIP instances Download: 4200 QIP instances with universal constrains","title":"Multistage Robust Assignment Problem"},{"location":"Instances/#multistage-robust-lot-sizing-problem","text":"We consider a single item lot-sizing problem with discrete ordering decisions and \\(T\\) periods 2 . At the beginning of each time period, the product demand that needs to be satisfied is disclosed: Either \\(dt\\) or \\(dt\\) . In order to serve the demand, in each period \\(t \\in \\left\\{0,...,T-1\\right\\}\\) one of \\(B\\) basic orders can be places resulting in the deliverance of corresponding quantity at the beginning of the subsequent period. Additionally, on of \\(U\\) urgent orders can be placed in each period \\(t\\in\\left\\{1,...,T\\right\\}\\) (with higher costs than the basic order), that is delivered in the same period. If the available quantity exceeds the demand, excess units are stored. Lot-Sizing instances have the naming scheme LotSizing-T-B-U-T.qlp. \\(R\\) is the seed for the random number generator. We provide the following testset: \\(T \\in \\left\\{5,6,7,8,9,10\\right\\}, B \\in \\left\\{3,4\\right\\} ~\\text{and}~ U \\in \\left\\{2,3\\right\\}\\) (50 instances per constellation): Download: 1200 QIP instances","title":"Multistage Robust Lot-Sizing Problem"},{"location":"Instances/#multistage-robust-knapsack-problem","text":"The task is to find a valid knapsack solution for each of \\(T\\) stages with \\(n\\) available items, where uncertainty in the item weights has been added 2 . The number of items with increased weight is budgeted: in each time step the weight of at most \\(\\alpha\\) items can be increased and overall at most \\(\\beta\\) such increases are allowed. The objective ist to maximize the profit resulting from the selected knapsack items but additionally a transition bonus is used to aim for a stable sequence of solutions. Knapsack instances have the naming scheme Knapsack_T-n-R.qlp. \\(R\\) is the seed for the random number generator. We provide the following testset: \\(n\\in \\left\\{2,...,7\\right\\} ~\\text{and}~ T\\in\\left\\{2,...,7\\right\\}\\) (50 instances per constellation): Download: 1800 QIP instances","title":"Multistage Robust Knapsack Problem"},{"location":"Instances/#runway-scheduling-instances","text":"For a set of airplanes \\(A\\) , a set of timeslots \\(S\\) , and \\(b\\) runways we are interested in a \\(b\\) -matching such that each airplane is assigned to exactly one time slot and each time slot contains at most \\(b\\) airplanes 1 . After an initial plan is determined, the time windows (a set of time slots) for a (sub)set of airplanes are disclosed. These airplanes must be assigned to their final time slot (within the given time window). This happens in a multistage manner with \\(s\\) being the number of disclosures, i.e. the number of universal variable blocks, e.g. \\(s=2\\) stands for the quantification sequence \\(\\exists~\\forall~\\exists~\\forall~\\exists\\) . The universal player is restricted in the way she is allowed to select the time windows: the overall time window lengths must exceed a given value. This can be modeled either explicitly by using universal constraints or implicitly by adding variables and constraint that detect and penalize such a violation. For a more thorough introduction we refer to this Ph.D. thesis 1 . Runway scheduling instances have the naming scheme RWS-|A|-b-|S|-s-R-t.qlp. Again, \\(R\\) is the seed for the random number generator. \\(t\\in\\left\\{s,u\\right\\}\\) represents the model type: \\(s\\) for \"standard QIP\" and \\(u\\) for \"QIP with universal constraints\". We provide the following testsets: \\(\\left|A\\right|\\in\\left\\{2,...,8\\right\\}, \\left|S\\right|\\in\\left\\{3,...,10\\right\\}, b\\in\\left\\{2,3,4\\right\\} ~\\text{with}~ s=1\\) (20 instances per constellation): Download: 3360 QIP instances Download: 3360 QIP instances with universal constrains \\(\\left|A\\right|=7, \\left|S\\right|=12, b=3 ~\\text{and}~ s\\in\\left\\{1,..,4\\right\\}\\) (300 instances per constellation): Download: 1200 QIP instances Download: 1200 QIP instances with universal constrains","title":"Runway Scheduling Instances"},{"location":"Instances/#other-instances","text":"The Quantified Satisfiability problem (QSAT), which is also know as the satisfiability of Quantified Boolean Formulas (QBF), is related to the Q-MIP-problem. In QSAT there is no objective function and all variables are binary. Further, it deals with clauses instead of arithmetic linear inequalities. However, with some effort and good will, it is possible to extract very special QMIPs from QSAT instances. Similar is the situation with MIPs, which deal with linear constraints but without quantification. Here, we present some further examples from these two sub-disciplines, collected from qbflib.org and miplib and converted to QLP-format. Instance collection IP based Instance collection MIP based Instance collection QBF based Please note that not all instances have been converted 1:1 due to some border cases in the conversion. 1 Further details can be found in this Ph.D. thesis 2 Further details can be found in this paper","title":"Other instances"},{"location":"Publications/","text":"Publications A general model-and-run solver for multistage robust discrete linear optimization The paper is available here . @article{hartisch2022general, title={A general model-and-run solver for multistage robust discrete linear optimization}, author={Hartisch, Michael and Lorenz, Ulf}, journal={arXiv preprint arXiv:2210.11132}, year={2022} } Quantified integer programming with polyhedral and decision-dependent The paper is available here . @phdthesis{hartisch2020quantified, title={Quantified integer programming with polyhedral and decision-dependent uncertainty}, author={Hartisch, Michael}, school={University of Siegen, Germany}, year={2020} } Multistage robust discrete optimization via quantified integer programming The paper is available here . @article{goerigk2021multistage, title={Multistage robust discrete optimization via quantified integer programming}, author={Goerigk, Marc and Hartisch, Michael}, journal={Computers \\& Operations Research}, volume={135}, pages={105434}, year={2021}, publisher={Elsevier} } Adaptive Relaxations for Multistage Robust Optimization The paper is available here . @inproceedings{hartisch2021adaptive, title={Adaptive Relaxations for Multistage Robust Optimization}, author={Hartisch, Michael}, booktitle={Pacific Rim International Conference on Artificial Intelligence}, pages={485--499}, year={2021}, organization={Springer} } A novel application for game tree search-exploiting pruning mechanisms for quantified integer programs The paper is available here . @article{hartisch2020quantified, title={Quantified integer programming with polyhedral and decision-dependent uncertainty}, author={Hartisch, Michael}, year={2020} } Robust multistage optimization with decision-dependent uncertainty The paper is available here . @inproceedings{hartisch2020robust, title={Robust multistage optimization with decision-dependent uncertainty}, author={Hartisch, Michael and Lorenz, Ulf}, booktitle={Operations Research Proceedings 2019: Selected Papers of the Annual International Conference of the German Operations Research Society (GOR), Dresden, Germany, September 4-6, 2019}, pages={439--445}, year={2020}, organization={Springer} } Yasol: an open source solver for quantified mixed integer programs The paper is available here . @inproceedings{ederer2017yasol, title={Yasol: an open source solver for quantified mixed integer programs}, author={Ederer, Thorsten and Hartisch, Michael and Lorenz, Ulf and Opfer, Thomas and Wolf, Jan}, booktitle={Advances in Computer Games: 15th International Conferences, ACG 2017, Leiden, The Netherlands, July 3--5, 2017, Revised Selected Papers 15}, pages={224--233}, year={2017}, organization={Springer} } Quantified Integer Programs with Polyhedral Uncertainty Set The paper is available here . @inproceedings{hartisch2016quantified, title={Quantified integer programs with polyhedral uncertainty set}, author={Hartisch, Michael and Ederer, Thorsten and Lorenz, Ulf and Wolf, Jan}, booktitle={Computers and Games: 9th International Conference, CG 2016, Leiden, The Netherlands, June 29--July 1, 2016, Revised Selected Papers 9}, pages={156--166}, year={2016}, organization={Springer} } Quantified linear programs: a computational study The paper is available here . @inproceedings{ederer2011quantified, title={Quantified linear programs: a computational study}, author={Ederer, Thorsten and Lorenz, Ulf and Martin, Alexander and Wolf, Jan}, booktitle={European Symposium on Algorithms}, pages={203--214}, year={2011}, organization={Springer} } Modeling games with the help of quantified integer linear programs The paper is available here . @inproceedings{ederer2012modeling, title={Modeling games with the help of quantified integer linear programs}, author={Ederer, Thorsten and Lorenz, Ulf and Opfer, Thomas and Wolf, Jan}, booktitle={Advances in Computer Games: 13th International Conference, ACG 2011, Tilburg, The Netherlands, November 20-22, 2011, Revised Selected Papers 13}, pages={270--281}, year={2012}, organization={Springer} } Quantified combinatorial optimization The paper is available here . @inproceedings{ederer2014quantified, title={Quantified combinatorial optimization}, author={Ederer, Thorsten and Lorenz, Ulf and Opfer, Thomas}, booktitle={Operations Research Proceedings 2013: Selected Papers of the International Conference on Operations Research, OR2013, organized by the German Operations Research Society (GOR), the Dutch Society of Operations Research (NGB) and Erasmus University Rotterdam, September 3-6, 2013}, pages={121--128}, year={2014}, organization={Springer} }","title":"Publications"},{"location":"Publications/#publications","text":"","title":"Publications"},{"location":"Publications/#a-general-model-and-run-solver-for-multistage-robust-discrete-linear-optimization","text":"The paper is available here . @article{hartisch2022general, title={A general model-and-run solver for multistage robust discrete linear optimization}, author={Hartisch, Michael and Lorenz, Ulf}, journal={arXiv preprint arXiv:2210.11132}, year={2022} }","title":"A general model-and-run solver for multistage robust discrete linear optimization"},{"location":"Publications/#quantified-integer-programming-with-polyhedral-and-decision-dependent","text":"The paper is available here . @phdthesis{hartisch2020quantified, title={Quantified integer programming with polyhedral and decision-dependent uncertainty}, author={Hartisch, Michael}, school={University of Siegen, Germany}, year={2020} }","title":"Quantified integer programming with polyhedral and decision-dependent"},{"location":"Publications/#multistage-robust-discrete-optimization-via-quantified-integer-programming","text":"The paper is available here . @article{goerigk2021multistage, title={Multistage robust discrete optimization via quantified integer programming}, author={Goerigk, Marc and Hartisch, Michael}, journal={Computers \\& Operations Research}, volume={135}, pages={105434}, year={2021}, publisher={Elsevier} }","title":"Multistage robust discrete optimization via quantified integer programming"},{"location":"Publications/#adaptive-relaxations-for-multistage-robust-optimization","text":"The paper is available here . @inproceedings{hartisch2021adaptive, title={Adaptive Relaxations for Multistage Robust Optimization}, author={Hartisch, Michael}, booktitle={Pacific Rim International Conference on Artificial Intelligence}, pages={485--499}, year={2021}, organization={Springer} }","title":"Adaptive Relaxations for Multistage Robust Optimization"},{"location":"Publications/#a-novel-application-for-game-tree-search-exploiting-pruning-mechanisms-for-quantified-integer-programs","text":"The paper is available here . @article{hartisch2020quantified, title={Quantified integer programming with polyhedral and decision-dependent uncertainty}, author={Hartisch, Michael}, year={2020} }","title":"A novel application for game tree search-exploiting pruning mechanisms for quantified integer programs"},{"location":"Publications/#robust-multistage-optimization-with-decision-dependent-uncertainty","text":"The paper is available here . @inproceedings{hartisch2020robust, title={Robust multistage optimization with decision-dependent uncertainty}, author={Hartisch, Michael and Lorenz, Ulf}, booktitle={Operations Research Proceedings 2019: Selected Papers of the Annual International Conference of the German Operations Research Society (GOR), Dresden, Germany, September 4-6, 2019}, pages={439--445}, year={2020}, organization={Springer} }","title":"Robust multistage optimization with decision-dependent uncertainty"},{"location":"Publications/#yasol-an-open-source-solver-for-quantified-mixed-integer-programs","text":"The paper is available here . @inproceedings{ederer2017yasol, title={Yasol: an open source solver for quantified mixed integer programs}, author={Ederer, Thorsten and Hartisch, Michael and Lorenz, Ulf and Opfer, Thomas and Wolf, Jan}, booktitle={Advances in Computer Games: 15th International Conferences, ACG 2017, Leiden, The Netherlands, July 3--5, 2017, Revised Selected Papers 15}, pages={224--233}, year={2017}, organization={Springer} }","title":"Yasol: an open source solver for quantified mixed integer programs"},{"location":"Publications/#quantified-integer-programs-with-polyhedral-uncertainty-set","text":"The paper is available here . @inproceedings{hartisch2016quantified, title={Quantified integer programs with polyhedral uncertainty set}, author={Hartisch, Michael and Ederer, Thorsten and Lorenz, Ulf and Wolf, Jan}, booktitle={Computers and Games: 9th International Conference, CG 2016, Leiden, The Netherlands, June 29--July 1, 2016, Revised Selected Papers 9}, pages={156--166}, year={2016}, organization={Springer} }","title":"Quantified Integer Programs with Polyhedral Uncertainty Set"},{"location":"Publications/#quantified-linear-programs-a-computational-study","text":"The paper is available here . @inproceedings{ederer2011quantified, title={Quantified linear programs: a computational study}, author={Ederer, Thorsten and Lorenz, Ulf and Martin, Alexander and Wolf, Jan}, booktitle={European Symposium on Algorithms}, pages={203--214}, year={2011}, organization={Springer} }","title":"Quantified linear programs: a computational study"},{"location":"Publications/#modeling-games-with-the-help-of-quantified-integer-linear-programs","text":"The paper is available here . @inproceedings{ederer2012modeling, title={Modeling games with the help of quantified integer linear programs}, author={Ederer, Thorsten and Lorenz, Ulf and Opfer, Thomas and Wolf, Jan}, booktitle={Advances in Computer Games: 13th International Conference, ACG 2011, Tilburg, The Netherlands, November 20-22, 2011, Revised Selected Papers 13}, pages={270--281}, year={2012}, organization={Springer} }","title":"Modeling games with the help of quantified integer linear programs"},{"location":"Publications/#quantified-combinatorial-optimization","text":"The paper is available here . @inproceedings{ederer2014quantified, title={Quantified combinatorial optimization}, author={Ederer, Thorsten and Lorenz, Ulf and Opfer, Thomas}, booktitle={Operations Research Proceedings 2013: Selected Papers of the International Conference on Operations Research, OR2013, organized by the German Operations Research Society (GOR), the Dutch Society of Operations Research (NGB) and Erasmus University Rotterdam, September 3-6, 2013}, pages={121--128}, year={2014}, organization={Springer} }","title":"Quantified combinatorial optimization"},{"location":"QMips/","text":"Q-MIPs Quantified (Mixed) Integer Linear Programming Mixed-integer linear programming (MIP) is a well-established state-of-the-art technique for computer-aided optimization. However, companies observe an increasing danger of disruptions that prevent them from acting as planned. One reason is that input data is often assumed to be deterministic, but in reality, they are afflicted with uncertainties which cannot be adequately described in MIPs, often. This is the point where Q-MIPs are intended to support future modeling. In 2007, Subramani coined the terms Quantified Linear Program and Quantified Integer Program and thus extended the traditional notions of Linear and Integer Programming 1 . The resulting quantified programs are both a strong modelling language and an intuitive input to next generation optimization software. We extended this notion one step further and introduced a minimax objective 2 : \\(\\textbf{Definition}~\\text{(Quantified Linear Program (QLP))}\\) . Let there be a vector \\(x = (x_1,...,x_n)^T \\in \\mathbb{Q}^n\\) of variables, integral lower and upper bounds \\(l \\in \\mathbb{Z}^n\\) with \\(l_i \\leq x_i \\leq u_i\\) , a coefficient matrix \\(A \\in \\mathbb{Q}^{m \\times n}\\) , a righthand side vector \\(b \\in \\mathbb{Q}^m\\) and a vector of quantifiers \\(Q = (Q_i, ..., Q_n)^T \\in \\left\\{\\forall, \\exists \\right\\}^n\\) , let the term \\(Q \\circ x \\in \\left[ l,u \\right]\\) with the component-wise binding operator \\(\\circ\\) denote the quantification vector \\((Q_1x_1 \\in \\left[ l_1,u_1 \\right], ..., Q_nx_n \\in \\left[ l_n, u_n \\right])^T\\) such that every quantifier \\(Q_i\\) binds the variable \\(x_i\\) ranging over the interval \\(\\left[ l_i, u_i \\right]\\) . Each maximal consecutive subsequence of \\(Q\\) consisting of identival quantifiers is called a quantifier block - the corresponding subsequence of \\(x\\) is called a variable block, with the \\(i\\) -th block being denoted by \\(x^{i}\\) . Let there also be a vector of objective coefficients \\(c \\in \\mathbb{Q}^n\\) . We call \\((Q, l, u, A, b, c)\\) with \\[\\begin{align} z = \\min_{x^1}(c^1x^1 + \\max_{x^2}(c^2x^2 + &\\min_{x^3}(c^3x^3 + \\max_{x^4}(... \\min_{x^m} c^mx^m)))) \\\\[5pt] Q \\circ x \\in &\\left[ l, u \\right]: Ax \\leq b \\end{align}\\] a quantified linear program (QLP) with objective function. ... as well as a restricted mixed version with the following attributes: the objective is minmax (more exactly: min max min \u2026 max min max) and is linear for any single game integer variables are allowed on all exist-stages (only) binary variables are allowed on universal stages continuous variables are allowed (only) on the last stage, assuming it is an existential stage quantifiers are either existential or universal 1 K. Subramani: On a decision procedure for quantified linear programs. Ann. Math. Artif. Intell. 51(1): 55-77 (2007) 2 U. Lorenz, J. Wolf: Solving Multistage Quantified Linear Optimization Problems with the Alph-beta nested Benders Decomposition, EURO Journal on Computational Optimization, pp. 349 - 370, Springer 2015 A tiny Q-MIP Let \\(x_1\\) and \\(x_3\\) be existential variables and \\(x_2\\) a universal variable. Thus we have, \\(\\exists x_1~ \\forall x_2~ \\exists x_3\\) . The aim is to find an optimal first stage setting for \\(x_1\\) such that the objective \\[ \\max_{x_1}(x_1 + \\min_{x_2}(x_2 + \\max_{x_3}(x_3))) \\] is optimized, and such that \\[\\begin{align} -2x_2 - x_3 &\\leq -2 \\\\[5pt] -x_1 + 2x_2 + x_3 &\\leq 2 \\\\[5pt] 2x_1 + 4x_2 &\\leq 6 \\\\[10pt] 0 \\leq x_1 \\leq 2 \\\\[5pt] 0 \\leq x_2 \\leq 1 \\\\[5pt] 0 \\leq x_3 \\leq 2 \\end{align}\\] Let \\(x_1\\) be integer, \\(x_2\\) binary, and \\(x_3\\) be continuous. Then the objective value is 3 and the optimal assignment of \\(x_1\\) is 1. Moreover, \\(x_3\\) should be set to either 0 or 2, depending on whether \\(x_2\\) becomes 1 or 0. It is possible to visualize the policy. In the following picture, you see an outer 3d-polytope which is caught in a box. That is the polytope which is generated by the existential LP-relaxation, i.e. all variables are assumed to be existential and continuous. Within the given polytope you see another one, in light red. That is the union of all 3D-points that are part of any feasible policy of the existential player, given the original \\(\\exists~\\forall~\\exists\\) quantifier string. You can also see that \\(x_1\\) can be set between 0 and 1 (i.e. half of the box in \\(x_1\\) -direction) and depending on how \\(x_2\\) is set (either 0 or 1), \\(x_3\\) can be moved up to its upper bound 2 or must smaller or equal to 1. You can download the QLP file for this instance. For a closer look at the file format see this page . A universal constraint system: Allowing polyhedral and decision-dependent uncertainty A QIP is inherently asymmetric, as even though the min-max semantic of the objective is symmetric, the universally quantified variables are only restricted to their domain (solely given by bounds), whereas the existential player\u2014in addition to having to obey the variable bounds\u2014also must ensure the fulfillment of the constraint system. In other words: only the existential player has to cope with a polytope influenced by the opponent\u2019s decisions whereby a polyhedral, or even decision-dependent, uncertainty set can only be modeled via tricky and not straight-forward modeling techniques. In order to be able to model the uncertainty set in a more simple way a second constraint system \\(A^\\forall x \\leq b^\\forall\\) was introduced, which allowed to explicitly model a polyhedral uncertainty set 1 . The usage of this universal constraint system was later extended to even allow decision-dependent uncertainty set 2 . For both modeling frameworks we also extended our solution framework 3 . Example: We consider a binary quantified program with an existential and a universal constraint system. As existentially quantified variables ( \\(x_1\\) and \\(x_2\\) ) have non-zero entries in the universal constraint system this instance is a QIP with decision-dependent uncertainty called QIP with interdependent domains. In particular, if both \\(x_1\\) and \\(x_2\\) are set to 1 the universal variable must not be 1. However, the existential player also has to ensure that setting \\(x_1\\) and \\(x_2\\) to 1 will no render the existential constraint system violated. As this is not the case, \\(x_1 = 1\\) and \\(x_2 = 1\\) is a legal variable assignment. In this case setting \\(x_3=1\\) would be an illegal assignment by the universal player, as it irrevocably violated the universal constraint system. \\[\\begin{align} c^Tx &: \\min x_1-2x_2+2x_3+x_4 \\\\[5pt] Q \\circ \\mathcal{L} &: \\exists x_1 \\in \\left\\{0, 1 \\right\\} \\exists x_2 \\in \\left\\{0, 1 \\right\\} \\forall x_3 \\in \\left\\{0, 1 \\right\\} \\exists x_4 \\in \\left\\{0, 1 \\right\\} \\\\[5pt] A^\\exists x \\leq b^\\exists &: \\begin{pmatrix} 1 & -2 & 1 & -1 \\\\ 1 & 1 & 1 & -1 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ \\end{pmatrix} \\leq \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} \\\\[5pt] A^\\forall x \\leq b^\\forall &: \\begin{pmatrix} 1 & 1 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ \\end{pmatrix} \\leq \\begin{pmatrix} 2 \\end{pmatrix} \\end{align}\\] The optimal solution of this instance is -1 with principal variation (1,1,0,0). In order to solve this instance with our solver, a universal constraint must be explicitly named in the QLP file using the keyword UNCERTAINTY SUBJECT TO [ Download instance ]. MINIMIZE x1 -2x2 +2x3 +x4 SUBJECT TO x1 -2x2 +x3 -x4 <= 1 x1 +x2 +x3 -x4 <= 2 UNCERTAINTY SUBJECT TO x1 +x2 +x3 <= 2 BOUNDS 0 <= x1 <= 1 0 <= x2 <= 1 0 <= x3 <= 1 0 <= x4 <= 1 BINARIES x1 x2 x3 x4 EXISTS x1 x2 x4 ALL x3 ORDER x1 x2 x3 x4 END Simply Restricted Instances: In order to ensure that universal variable assignments are legal, i.e. that they do not eventually result in a violation of the universal constraint system, the feasibility of the universal constraint system must be checked in each step. This can be tedious as this means solving an IP at each universal decision node. However, we observed the following in many multistage robust problems: Uncertainty maybe can be manipulated, but it cannot be 'defeated' in the sense that no legal move remains. Potential realizations of uncertain parameters are easily recognizable, i.e. classifying a universal variable assignment as legal or illegal should not be an NP-complete problem. We formalized this observation and we call instances those observations apply to simply restricted. \\(\\textbf{Definition}~(\\text{Simply Restricted}~QIP^{ID})\\) . Let \\(P = (A^\\exists, A^\\forall, b^\\exists, b^\\forall, c, \\mathcal{L}, Q)\\) be a \\(QIP^{ID}\\) . If the two following conditions are fulfilled, we call \\(P\\) a simply restricted \\(QIP^{ID}\\) . For each universal variable block \\(i \\in \\mathcal{A}\\) we demand \\[\\begin{equation*} \\forall~ (\\hat{x}^{(1)}\\in \\mathcal{L}^{(1)}, \\hat{x}^{(2)} \\in \\mathcal{F}^{(2)}, ..., \\hat{x}^{(i-2)} \\in \\mathcal{F}^{(i-2)}, \\hat{x}^{(i-1)} \\in \\mathcal{L}^{(i-1)}): \\mathcal{F}^{(i)} \\neq \\emptyset. \\end{equation*}\\] Let \\(i \\in \\mathcal{A}\\) and let \\(\\hat{x}^{(1)} \\in \\mathcal{L}^{(1)}, ..., \\hat{x}^{(i-1)} \\in \\mathcal{L}^{(i-1)}\\) be a partial variable assignment up to block \\(i\\) . If \\(\\tilde{x}^{(i)} \\not\\in \\mathcal{F}^{(i)} (\\hat{x}^{(1)}, ..., \\hat{x}^{(i-1)})\\) , then \\[\\begin{equation*} \\exists ~ k \\in \\left\\{ 1, ..., m_\\forall \\right\\}: \\sum_{j < i} A_{k,(j)}^\\forall \\hat{x}^{(j)} + A_{k,(i)}^\\forall \\tilde{x}^{(i)} + \\sum_{j>i} \\min_{x^{(j)} \\in \\mathcal{L}^{(j)}} A_{k,(j)}^\\forall x^{(j)} \\not \\leq b_k^\\forall. \\end{equation*}\\] The benefit of having a simply restricted instance is that then the legality of a universal variable assignment can be checked be simply traversing the universal constraints and checking whether they remain satisfiable, even in the worst case. Thus, the satisfiability of entire universal constraint system can be checked locally rather than solving the entire IP. If your instance is simply restricted you can specify \"isSimplyRestricted=1\" in the Yasol.ini file. If your instance does not fulfill the requirements, or if you are not sure, simply set \"isSimplyRestricted\" to zero, and each universal variable assignment will be verified by solving the corresponding universal IP. 1 M. Hartisch, T. Ederer, U. Lorenz, J. Wolf. Quantified Integer Programs with Polyhedral Uncertainty Set . In: A. Plaat, W. Kosters, J. van den Herik (eds) Computers and Games. CG 2016. Lecture Notes in Computer Science, vol 10068. Springer, Cham, 2016 2 M. Hartisch, U. Lorenz. Mastering uncertainty: Towards robust multistage optimization with decision dependent uncertainty . In 16th Pacific Rim International Conference on Artificial Intelligence, PRICAI 2019, Seiten 446\u2013458. Springer, 2019 3 M. Hartisch. Quantified Integer Programming with Polyhedral and Decision-Dependent Uncertainty . PhD thesis, University of Siegen, Germany, 2020 Quantified Programs applied to Runway Scheduling The following QIP problem definition and, as a consequence the content of this page, is a result of cooperative work between University Siegen (S. Gnad, M. Hartisch, U. Lorenz) and FAU Erlangen (L. Hupp, F. Liers, A. Peter). We used QIPs to model and solve a matching problem that can be interpreted as an airplane scheduling problem in which each airplane must be assigned to a time slot and at most b airplanes can be assigned to one time slot. This b-matching is enhanced by uncertain time intervals in which an airplane must land. For reasons of simplicity we will use the airplane scheduling interpretation to explain our intentions. Figure: Example with 4 airplanes and 6 possible time slots. 2 airplanes can be scheduled at each time slot (b=2). The initial planning costs are given and the possible time windows (consisting of two time slots) for each airplane are depicted as sliders below. Broadly speaking, we are interested in an initial plan that can be fixed cheaply if the mandatory time windows (the sliders in the figure) for some planes do not contain the initially scheduled time slot. Reasons for such variations (in the arrival time) might be adjusted airspeed (due to weather) or operational problems. The incurred costs are composed of the costs for the initial plan and the fixing costs. The costs for the initial plan only depend on the the initial assignment of planes to time slots regarding predetermined costs: In the example above assigning airplane 2 to time slot 4 would result in costs of 2 monetary units. There are some ideas for the composition of the fixing costs, for example: rescheduling one airplane results in a fixed fee rescheduling one airplane results in costs depending on the newly selected time slot rescheduling one airplane results in costs depending on the initial and the newly selected time slot For simplicity and a more general presentation, the costs of replacing airplane i depend on a function \\(f(x_{i^*},y_{i^*})\\) representing the relation between initial plan, fixed plan and fixing costs. Depending on the selected cost type, this function can be modeled using linear constraints. Basic quantified program for the airplane runway scheduling problem: \\[\\begin{align} \\min \\quad & \\sum_{i \\in A}\\sum_{j \\in W} c_{i,j}x_{i,j} + \\max \\left\\{ \\min \\left\\{ \\sum_{i \\in A} c_i^{fix} \\right\\} \\right\\} \\\\ \\mathrm{s.t.} \\quad & \\exists X \\in \\left\\{0, 1 \\right\\}^{\\left| A \\right| \\times \\left| W \\right|} \\\\ & \\forall S \\in \\mathcal{S}, L \\in \\mathcal{L} \\\\ & \\exists Y \\in \\left\\{0, 1 \\right\\}^{\\left| A \\right| \\times \\left| W \\right|}: \\\\ & \\sum_{j \\in W} x_{i,j} = 1 \\quad && \\forall i \\in A \\\\ & \\sum_{i \\in A} x_{i,j} \\leq b \\quad && \\forall j \\in W \\\\ & \\sum_{j \\in W} y_{i,j} = 1 \\quad && \\forall i \\in A \\\\ & \\sum_{i \\in A} y_{i,j} \\leq b \\quad && \\forall j \\in W \\\\ & s_i \\leq \\sum_{j \\in W} j \\cdot y_{i,j} \\leq s_i+l_i \\quad && \\forall i \\in A \\\\ & c_i^{fix} = f(x_{i,*}, y_{i,*}) \\quad && \\forall i \\in A \\\\ \\end{align}\\] Brief explanation of the model: three stage objective function first stage: select initial plan resulting in initial costs second stage: uncertain events \u2192 new conditions regarding allowed time slots (the start \\((s_i \\in S)\\) and the length \\((l_i \\in L)\\) of the time window is selected for each airplane \\(i\\) ) third stage: if necessary fix the initial plan causing additional costs First stage existential variables: Initial scheduling variables Second stage universal variables: Specification of the starting point ( \\(s\\) ) and the length ( \\(l\\) ) of the mandatory time window for each airplane Third stage existential variables: Final scheduling variables respecting the time windows defined in stage two Ensures that each airplane is assigned to exactly one time slot in the initial plan Ensures that each time slot can only hold b airplanes in the initial plan Ensures that each airplane is assigned to exactly one time slot in the fixed plan Ensures that each time slot can only hold b airplanes in the fixed plan Binds the assigned time slots of the fixed plan to the given time window Fixing costs depend on difference between initial plan ( \\(X\\) ) and fixed plan ( \\(Y\\) ); various cost models imaginable. Example costs: fixed fee If, for example, the first mentioned fixing costs were used, i.e. fixed fee for replanning, further existential variables \\(Z \\in \\left\\{0,1\\right\\}^{\\left|A\\right| \\times \\left|W\\right|}\\) are installed in the third stage and the following constraints would be added: \\[\\begin{align} Z \\in \\left\\{0,1\\right\\}^{\\left|A\\right| \\times \\left|W\\right|} \\\\[8pt] z_{i,j} \\geq y_{i,j} - x_{i,j} \\quad &\\forall i \\in A, j \\in W \\\\[8pt] c_i^{fix} = \\sum_{j \\in W} fz_{i,j} \\quad &\\forall i \\in A \\end{align}\\] In this case variable \\(z_{i,j}\\) must identify if airplane \\(i\\) was not scheduled in time slot \\(j\\) in the initial plan but in the fixed plan resulting in costs \\(f\\) for this plane. Restricting the universal variables: By choosing the domains of the universal variables \\(S\\) and \\(L\\) carefully the user already can limit the influence of the universal variables. Nevertheless, some scenarios should not be considered: For example one might want to allow the time windows for some airplane to consist of only one time slot. However, this should not be the case for all airplanes, since this would constitute a rather implausible event. One conceivable demand for the time windows could be that on average the time windows have a length of 2 (i.e. consist of two time slots). Thus, the universal variables L should not only be forced to lie within some bounds, but also within a specific polytope. The polytope for this example would require the following additional constraint: \\[ \\frac{1}{\\left|A\\right|}\\sum_{i \\in A}l_i \\geq 2 \\] However, simply adding this constraint to the constraint system would not have the desired effect. In fact, it would increase the influence of the universal variables since this constraint could easily be violated and thus the entire instance would become infeasible. However, adding this as a universal constraint would do the trick. or the enforcement of rules regarding the universal variables could be performed implicitly: In a final existential block the fulfillment of such a constraint is checked and if a violation is detected the remaining constraint system is relaxed and the objective value is reduced dramatically. This has the effect that a violation provoked by the allocation of universal variables results in a very good objective value (regarding the existential objective of minimization) and is thus unfavorable with respect to the universal maximization objective. Instances: For this runway scheduling problem we created several instances with several variations: Instances with more than 3 stages: After the initial plan the time windows for some airplanes are selected by the universal variables. For these airplanes a fixed plan must be prepared. After that the time windows for the remaining airplanes are specified by the universal variables and once again the plan must be fixed. Instances with restricted universal variables: As explained above, the universal variables determining the interval lengths must obey some rules. Instances with different objective function: the first (fixed fee) and third (distance from initial and final time slot) presented fixing costs are considered. Instances with diverse time windows: The interval length can vary from 0 up to 4 time slots and the interval itself can start at up to 4 time slots. Instances with different numbers of airplanes and time slots: the number of airplanes varies between 5 and up to more than 100. The number of time slots varies between 7 and up to 200 time slots. Download Instances For each of these 29 instances our solver Yasol (utilizing the Cplex LP solver) had one hour to solve the instance. The results where compared to Cplex trying to solve the corresponding deterministic equivalent program, also within one hour. The results are displayed in the following table. Yasol solves 25 out of the 29 instances while CPLEX only can solve 6 of the converted DEPs. Even when only considering the instances solved by CPLEX, Yasol only needs 2.66 seconds on average compared to 6.83 seconds. If instances get large (easy indicator is the number right after the 'A' in the instance name) Yasol is able to detect infeasible instances rather fast but does not manage to grasp optimal feasible solutions. CPLEX, on the other hand, often exceeds the available memory on such instances and does not cope very well if many universal variables are present. But even on instances with few universal variables CPLEX quickly reaches its limit. 1 Hartisch M., Ederer T., Lorenz U., Wolf J. (2016) Quantified Integer Programs with Polyhedral Uncertainty Set. In: Plaat A., Kosters W., van den Herik J. (eds) Computers and Games. CG 2016. Lecture Notes in Computer Science, vol 10068. Springer, Cham","title":"Q-MIPs"},{"location":"QMips/#q-mips","text":"","title":"Q-MIPs"},{"location":"QMips/#quantified-mixed-integer-linear-programming","text":"Mixed-integer linear programming (MIP) is a well-established state-of-the-art technique for computer-aided optimization. However, companies observe an increasing danger of disruptions that prevent them from acting as planned. One reason is that input data is often assumed to be deterministic, but in reality, they are afflicted with uncertainties which cannot be adequately described in MIPs, often. This is the point where Q-MIPs are intended to support future modeling. In 2007, Subramani coined the terms Quantified Linear Program and Quantified Integer Program and thus extended the traditional notions of Linear and Integer Programming 1 . The resulting quantified programs are both a strong modelling language and an intuitive input to next generation optimization software. We extended this notion one step further and introduced a minimax objective 2 : \\(\\textbf{Definition}~\\text{(Quantified Linear Program (QLP))}\\) . Let there be a vector \\(x = (x_1,...,x_n)^T \\in \\mathbb{Q}^n\\) of variables, integral lower and upper bounds \\(l \\in \\mathbb{Z}^n\\) with \\(l_i \\leq x_i \\leq u_i\\) , a coefficient matrix \\(A \\in \\mathbb{Q}^{m \\times n}\\) , a righthand side vector \\(b \\in \\mathbb{Q}^m\\) and a vector of quantifiers \\(Q = (Q_i, ..., Q_n)^T \\in \\left\\{\\forall, \\exists \\right\\}^n\\) , let the term \\(Q \\circ x \\in \\left[ l,u \\right]\\) with the component-wise binding operator \\(\\circ\\) denote the quantification vector \\((Q_1x_1 \\in \\left[ l_1,u_1 \\right], ..., Q_nx_n \\in \\left[ l_n, u_n \\right])^T\\) such that every quantifier \\(Q_i\\) binds the variable \\(x_i\\) ranging over the interval \\(\\left[ l_i, u_i \\right]\\) . Each maximal consecutive subsequence of \\(Q\\) consisting of identival quantifiers is called a quantifier block - the corresponding subsequence of \\(x\\) is called a variable block, with the \\(i\\) -th block being denoted by \\(x^{i}\\) . Let there also be a vector of objective coefficients \\(c \\in \\mathbb{Q}^n\\) . We call \\((Q, l, u, A, b, c)\\) with \\[\\begin{align} z = \\min_{x^1}(c^1x^1 + \\max_{x^2}(c^2x^2 + &\\min_{x^3}(c^3x^3 + \\max_{x^4}(... \\min_{x^m} c^mx^m)))) \\\\[5pt] Q \\circ x \\in &\\left[ l, u \\right]: Ax \\leq b \\end{align}\\] a quantified linear program (QLP) with objective function. ... as well as a restricted mixed version with the following attributes: the objective is minmax (more exactly: min max min \u2026 max min max) and is linear for any single game integer variables are allowed on all exist-stages (only) binary variables are allowed on universal stages continuous variables are allowed (only) on the last stage, assuming it is an existential stage quantifiers are either existential or universal 1 K. Subramani: On a decision procedure for quantified linear programs. Ann. Math. Artif. Intell. 51(1): 55-77 (2007) 2 U. Lorenz, J. Wolf: Solving Multistage Quantified Linear Optimization Problems with the Alph-beta nested Benders Decomposition, EURO Journal on Computational Optimization, pp. 349 - 370, Springer 2015","title":"Quantified (Mixed) Integer Linear Programming"},{"location":"QMips/#a-tiny-q-mip","text":"Let \\(x_1\\) and \\(x_3\\) be existential variables and \\(x_2\\) a universal variable. Thus we have, \\(\\exists x_1~ \\forall x_2~ \\exists x_3\\) . The aim is to find an optimal first stage setting for \\(x_1\\) such that the objective \\[ \\max_{x_1}(x_1 + \\min_{x_2}(x_2 + \\max_{x_3}(x_3))) \\] is optimized, and such that \\[\\begin{align} -2x_2 - x_3 &\\leq -2 \\\\[5pt] -x_1 + 2x_2 + x_3 &\\leq 2 \\\\[5pt] 2x_1 + 4x_2 &\\leq 6 \\\\[10pt] 0 \\leq x_1 \\leq 2 \\\\[5pt] 0 \\leq x_2 \\leq 1 \\\\[5pt] 0 \\leq x_3 \\leq 2 \\end{align}\\] Let \\(x_1\\) be integer, \\(x_2\\) binary, and \\(x_3\\) be continuous. Then the objective value is 3 and the optimal assignment of \\(x_1\\) is 1. Moreover, \\(x_3\\) should be set to either 0 or 2, depending on whether \\(x_2\\) becomes 1 or 0. It is possible to visualize the policy. In the following picture, you see an outer 3d-polytope which is caught in a box. That is the polytope which is generated by the existential LP-relaxation, i.e. all variables are assumed to be existential and continuous. Within the given polytope you see another one, in light red. That is the union of all 3D-points that are part of any feasible policy of the existential player, given the original \\(\\exists~\\forall~\\exists\\) quantifier string. You can also see that \\(x_1\\) can be set between 0 and 1 (i.e. half of the box in \\(x_1\\) -direction) and depending on how \\(x_2\\) is set (either 0 or 1), \\(x_3\\) can be moved up to its upper bound 2 or must smaller or equal to 1. You can download the QLP file for this instance. For a closer look at the file format see this page .","title":"A tiny Q-MIP"},{"location":"QMips/#a-universal-constraint-system-allowing-polyhedral-and-decision-dependent-uncertainty","text":"A QIP is inherently asymmetric, as even though the min-max semantic of the objective is symmetric, the universally quantified variables are only restricted to their domain (solely given by bounds), whereas the existential player\u2014in addition to having to obey the variable bounds\u2014also must ensure the fulfillment of the constraint system. In other words: only the existential player has to cope with a polytope influenced by the opponent\u2019s decisions whereby a polyhedral, or even decision-dependent, uncertainty set can only be modeled via tricky and not straight-forward modeling techniques. In order to be able to model the uncertainty set in a more simple way a second constraint system \\(A^\\forall x \\leq b^\\forall\\) was introduced, which allowed to explicitly model a polyhedral uncertainty set 1 . The usage of this universal constraint system was later extended to even allow decision-dependent uncertainty set 2 . For both modeling frameworks we also extended our solution framework 3 . Example: We consider a binary quantified program with an existential and a universal constraint system. As existentially quantified variables ( \\(x_1\\) and \\(x_2\\) ) have non-zero entries in the universal constraint system this instance is a QIP with decision-dependent uncertainty called QIP with interdependent domains. In particular, if both \\(x_1\\) and \\(x_2\\) are set to 1 the universal variable must not be 1. However, the existential player also has to ensure that setting \\(x_1\\) and \\(x_2\\) to 1 will no render the existential constraint system violated. As this is not the case, \\(x_1 = 1\\) and \\(x_2 = 1\\) is a legal variable assignment. In this case setting \\(x_3=1\\) would be an illegal assignment by the universal player, as it irrevocably violated the universal constraint system. \\[\\begin{align} c^Tx &: \\min x_1-2x_2+2x_3+x_4 \\\\[5pt] Q \\circ \\mathcal{L} &: \\exists x_1 \\in \\left\\{0, 1 \\right\\} \\exists x_2 \\in \\left\\{0, 1 \\right\\} \\forall x_3 \\in \\left\\{0, 1 \\right\\} \\exists x_4 \\in \\left\\{0, 1 \\right\\} \\\\[5pt] A^\\exists x \\leq b^\\exists &: \\begin{pmatrix} 1 & -2 & 1 & -1 \\\\ 1 & 1 & 1 & -1 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ \\end{pmatrix} \\leq \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} \\\\[5pt] A^\\forall x \\leq b^\\forall &: \\begin{pmatrix} 1 & 1 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ \\end{pmatrix} \\leq \\begin{pmatrix} 2 \\end{pmatrix} \\end{align}\\] The optimal solution of this instance is -1 with principal variation (1,1,0,0). In order to solve this instance with our solver, a universal constraint must be explicitly named in the QLP file using the keyword UNCERTAINTY SUBJECT TO [ Download instance ]. MINIMIZE x1 -2x2 +2x3 +x4 SUBJECT TO x1 -2x2 +x3 -x4 <= 1 x1 +x2 +x3 -x4 <= 2 UNCERTAINTY SUBJECT TO x1 +x2 +x3 <= 2 BOUNDS 0 <= x1 <= 1 0 <= x2 <= 1 0 <= x3 <= 1 0 <= x4 <= 1 BINARIES x1 x2 x3 x4 EXISTS x1 x2 x4 ALL x3 ORDER x1 x2 x3 x4 END Simply Restricted Instances: In order to ensure that universal variable assignments are legal, i.e. that they do not eventually result in a violation of the universal constraint system, the feasibility of the universal constraint system must be checked in each step. This can be tedious as this means solving an IP at each universal decision node. However, we observed the following in many multistage robust problems: Uncertainty maybe can be manipulated, but it cannot be 'defeated' in the sense that no legal move remains. Potential realizations of uncertain parameters are easily recognizable, i.e. classifying a universal variable assignment as legal or illegal should not be an NP-complete problem. We formalized this observation and we call instances those observations apply to simply restricted. \\(\\textbf{Definition}~(\\text{Simply Restricted}~QIP^{ID})\\) . Let \\(P = (A^\\exists, A^\\forall, b^\\exists, b^\\forall, c, \\mathcal{L}, Q)\\) be a \\(QIP^{ID}\\) . If the two following conditions are fulfilled, we call \\(P\\) a simply restricted \\(QIP^{ID}\\) . For each universal variable block \\(i \\in \\mathcal{A}\\) we demand \\[\\begin{equation*} \\forall~ (\\hat{x}^{(1)}\\in \\mathcal{L}^{(1)}, \\hat{x}^{(2)} \\in \\mathcal{F}^{(2)}, ..., \\hat{x}^{(i-2)} \\in \\mathcal{F}^{(i-2)}, \\hat{x}^{(i-1)} \\in \\mathcal{L}^{(i-1)}): \\mathcal{F}^{(i)} \\neq \\emptyset. \\end{equation*}\\] Let \\(i \\in \\mathcal{A}\\) and let \\(\\hat{x}^{(1)} \\in \\mathcal{L}^{(1)}, ..., \\hat{x}^{(i-1)} \\in \\mathcal{L}^{(i-1)}\\) be a partial variable assignment up to block \\(i\\) . If \\(\\tilde{x}^{(i)} \\not\\in \\mathcal{F}^{(i)} (\\hat{x}^{(1)}, ..., \\hat{x}^{(i-1)})\\) , then \\[\\begin{equation*} \\exists ~ k \\in \\left\\{ 1, ..., m_\\forall \\right\\}: \\sum_{j < i} A_{k,(j)}^\\forall \\hat{x}^{(j)} + A_{k,(i)}^\\forall \\tilde{x}^{(i)} + \\sum_{j>i} \\min_{x^{(j)} \\in \\mathcal{L}^{(j)}} A_{k,(j)}^\\forall x^{(j)} \\not \\leq b_k^\\forall. \\end{equation*}\\] The benefit of having a simply restricted instance is that then the legality of a universal variable assignment can be checked be simply traversing the universal constraints and checking whether they remain satisfiable, even in the worst case. Thus, the satisfiability of entire universal constraint system can be checked locally rather than solving the entire IP. If your instance is simply restricted you can specify \"isSimplyRestricted=1\" in the Yasol.ini file. If your instance does not fulfill the requirements, or if you are not sure, simply set \"isSimplyRestricted\" to zero, and each universal variable assignment will be verified by solving the corresponding universal IP. 1 M. Hartisch, T. Ederer, U. Lorenz, J. Wolf. Quantified Integer Programs with Polyhedral Uncertainty Set . In: A. Plaat, W. Kosters, J. van den Herik (eds) Computers and Games. CG 2016. Lecture Notes in Computer Science, vol 10068. Springer, Cham, 2016 2 M. Hartisch, U. Lorenz. Mastering uncertainty: Towards robust multistage optimization with decision dependent uncertainty . In 16th Pacific Rim International Conference on Artificial Intelligence, PRICAI 2019, Seiten 446\u2013458. Springer, 2019 3 M. Hartisch. Quantified Integer Programming with Polyhedral and Decision-Dependent Uncertainty . PhD thesis, University of Siegen, Germany, 2020","title":"A universal constraint system: Allowing polyhedral and decision-dependent uncertainty"},{"location":"QMips/#quantified-programs-applied-to-runway-scheduling","text":"The following QIP problem definition and, as a consequence the content of this page, is a result of cooperative work between University Siegen (S. Gnad, M. Hartisch, U. Lorenz) and FAU Erlangen (L. Hupp, F. Liers, A. Peter). We used QIPs to model and solve a matching problem that can be interpreted as an airplane scheduling problem in which each airplane must be assigned to a time slot and at most b airplanes can be assigned to one time slot. This b-matching is enhanced by uncertain time intervals in which an airplane must land. For reasons of simplicity we will use the airplane scheduling interpretation to explain our intentions. Figure: Example with 4 airplanes and 6 possible time slots. 2 airplanes can be scheduled at each time slot (b=2). The initial planning costs are given and the possible time windows (consisting of two time slots) for each airplane are depicted as sliders below. Broadly speaking, we are interested in an initial plan that can be fixed cheaply if the mandatory time windows (the sliders in the figure) for some planes do not contain the initially scheduled time slot. Reasons for such variations (in the arrival time) might be adjusted airspeed (due to weather) or operational problems. The incurred costs are composed of the costs for the initial plan and the fixing costs. The costs for the initial plan only depend on the the initial assignment of planes to time slots regarding predetermined costs: In the example above assigning airplane 2 to time slot 4 would result in costs of 2 monetary units. There are some ideas for the composition of the fixing costs, for example: rescheduling one airplane results in a fixed fee rescheduling one airplane results in costs depending on the newly selected time slot rescheduling one airplane results in costs depending on the initial and the newly selected time slot For simplicity and a more general presentation, the costs of replacing airplane i depend on a function \\(f(x_{i^*},y_{i^*})\\) representing the relation between initial plan, fixed plan and fixing costs. Depending on the selected cost type, this function can be modeled using linear constraints. Basic quantified program for the airplane runway scheduling problem: \\[\\begin{align} \\min \\quad & \\sum_{i \\in A}\\sum_{j \\in W} c_{i,j}x_{i,j} + \\max \\left\\{ \\min \\left\\{ \\sum_{i \\in A} c_i^{fix} \\right\\} \\right\\} \\\\ \\mathrm{s.t.} \\quad & \\exists X \\in \\left\\{0, 1 \\right\\}^{\\left| A \\right| \\times \\left| W \\right|} \\\\ & \\forall S \\in \\mathcal{S}, L \\in \\mathcal{L} \\\\ & \\exists Y \\in \\left\\{0, 1 \\right\\}^{\\left| A \\right| \\times \\left| W \\right|}: \\\\ & \\sum_{j \\in W} x_{i,j} = 1 \\quad && \\forall i \\in A \\\\ & \\sum_{i \\in A} x_{i,j} \\leq b \\quad && \\forall j \\in W \\\\ & \\sum_{j \\in W} y_{i,j} = 1 \\quad && \\forall i \\in A \\\\ & \\sum_{i \\in A} y_{i,j} \\leq b \\quad && \\forall j \\in W \\\\ & s_i \\leq \\sum_{j \\in W} j \\cdot y_{i,j} \\leq s_i+l_i \\quad && \\forall i \\in A \\\\ & c_i^{fix} = f(x_{i,*}, y_{i,*}) \\quad && \\forall i \\in A \\\\ \\end{align}\\] Brief explanation of the model: three stage objective function first stage: select initial plan resulting in initial costs second stage: uncertain events \u2192 new conditions regarding allowed time slots (the start \\((s_i \\in S)\\) and the length \\((l_i \\in L)\\) of the time window is selected for each airplane \\(i\\) ) third stage: if necessary fix the initial plan causing additional costs First stage existential variables: Initial scheduling variables Second stage universal variables: Specification of the starting point ( \\(s\\) ) and the length ( \\(l\\) ) of the mandatory time window for each airplane Third stage existential variables: Final scheduling variables respecting the time windows defined in stage two Ensures that each airplane is assigned to exactly one time slot in the initial plan Ensures that each time slot can only hold b airplanes in the initial plan Ensures that each airplane is assigned to exactly one time slot in the fixed plan Ensures that each time slot can only hold b airplanes in the fixed plan Binds the assigned time slots of the fixed plan to the given time window Fixing costs depend on difference between initial plan ( \\(X\\) ) and fixed plan ( \\(Y\\) ); various cost models imaginable. Example costs: fixed fee If, for example, the first mentioned fixing costs were used, i.e. fixed fee for replanning, further existential variables \\(Z \\in \\left\\{0,1\\right\\}^{\\left|A\\right| \\times \\left|W\\right|}\\) are installed in the third stage and the following constraints would be added: \\[\\begin{align} Z \\in \\left\\{0,1\\right\\}^{\\left|A\\right| \\times \\left|W\\right|} \\\\[8pt] z_{i,j} \\geq y_{i,j} - x_{i,j} \\quad &\\forall i \\in A, j \\in W \\\\[8pt] c_i^{fix} = \\sum_{j \\in W} fz_{i,j} \\quad &\\forall i \\in A \\end{align}\\] In this case variable \\(z_{i,j}\\) must identify if airplane \\(i\\) was not scheduled in time slot \\(j\\) in the initial plan but in the fixed plan resulting in costs \\(f\\) for this plane. Restricting the universal variables: By choosing the domains of the universal variables \\(S\\) and \\(L\\) carefully the user already can limit the influence of the universal variables. Nevertheless, some scenarios should not be considered: For example one might want to allow the time windows for some airplane to consist of only one time slot. However, this should not be the case for all airplanes, since this would constitute a rather implausible event. One conceivable demand for the time windows could be that on average the time windows have a length of 2 (i.e. consist of two time slots). Thus, the universal variables L should not only be forced to lie within some bounds, but also within a specific polytope. The polytope for this example would require the following additional constraint: \\[ \\frac{1}{\\left|A\\right|}\\sum_{i \\in A}l_i \\geq 2 \\] However, simply adding this constraint to the constraint system would not have the desired effect. In fact, it would increase the influence of the universal variables since this constraint could easily be violated and thus the entire instance would become infeasible. However, adding this as a universal constraint would do the trick. or the enforcement of rules regarding the universal variables could be performed implicitly: In a final existential block the fulfillment of such a constraint is checked and if a violation is detected the remaining constraint system is relaxed and the objective value is reduced dramatically. This has the effect that a violation provoked by the allocation of universal variables results in a very good objective value (regarding the existential objective of minimization) and is thus unfavorable with respect to the universal maximization objective. Instances: For this runway scheduling problem we created several instances with several variations: Instances with more than 3 stages: After the initial plan the time windows for some airplanes are selected by the universal variables. For these airplanes a fixed plan must be prepared. After that the time windows for the remaining airplanes are specified by the universal variables and once again the plan must be fixed. Instances with restricted universal variables: As explained above, the universal variables determining the interval lengths must obey some rules. Instances with different objective function: the first (fixed fee) and third (distance from initial and final time slot) presented fixing costs are considered. Instances with diverse time windows: The interval length can vary from 0 up to 4 time slots and the interval itself can start at up to 4 time slots. Instances with different numbers of airplanes and time slots: the number of airplanes varies between 5 and up to more than 100. The number of time slots varies between 7 and up to 200 time slots. Download Instances For each of these 29 instances our solver Yasol (utilizing the Cplex LP solver) had one hour to solve the instance. The results where compared to Cplex trying to solve the corresponding deterministic equivalent program, also within one hour. The results are displayed in the following table. Yasol solves 25 out of the 29 instances while CPLEX only can solve 6 of the converted DEPs. Even when only considering the instances solved by CPLEX, Yasol only needs 2.66 seconds on average compared to 6.83 seconds. If instances get large (easy indicator is the number right after the 'A' in the instance name) Yasol is able to detect infeasible instances rather fast but does not manage to grasp optimal feasible solutions. CPLEX, on the other hand, often exceeds the available memory on such instances and does not cope very well if many universal variables are present. But even on instances with few universal variables CPLEX quickly reaches its limit. 1 Hartisch M., Ederer T., Lorenz U., Wolf J. (2016) Quantified Integer Programs with Polyhedral Uncertainty Set. In: Plaat A., Kosters W., van den Herik J. (eds) Computers and Games. CG 2016. Lecture Notes in Computer Science, vol 10068. Springer, Cham","title":"Quantified Programs applied to Runway Scheduling"},{"location":"Team/","text":"Team Developers: Ulf Lorenz , project head and main contributor Michael Hartisch , contributor math programming, main contact for user service Other Pages: Homepage Git","title":"Team"},{"location":"Team/#team","text":"Developers: Ulf Lorenz , project head and main contributor Michael Hartisch , contributor math programming, main contact for user service Other Pages: Homepage Git","title":"Team"}]}